---
lang: zh-CN
title: ● 基础知识
description: Javascript 的描述
---

## ➣ 基本数据类型和引用数据类型

1. 基本数据类型：String/Boolean/Number/Null/Undefined/Symbol/BigInt(ES2020)
2. 引用数据类型：Function/Object/Array

## ➣ let/const/var 区别

- 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部。
- var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。
- var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会。
- let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。

## ➣ 字符串操作方法 slice / substring / substr

### 一、相同点

- 这三个方法都返回调用他们的字符串的一个子字符串，也就是不会改变原字符串
- 都接收一到两个参数，第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置
- 省略第二个参数都表示提取到末尾

### 二、不同点

- 对 slice() 和 substring() 而言，第二个参数是提取结束的位置 (即该位置之前的字符会被提取出来)。对 substr() 而言，第二个参数表示返回的子字符串数量。

### 三、示例

#### 1. 参数为正

```javascript
let str = 'hello word';

console.log(str.slice(3)); // "lo word" - 从第三位开始截取
console.log(str.substr(3));  // "lo word" - 从第三位开始截取
console.log(str.substring(3));  // "lo word" - 从第三位开始截取

console.log(str.slice(3, 7));  // "lo w" - 从第三位开始截取到第七个字符
console.log(str.substring(3, 7));  // "lo w" - 从第三位开始截取到第七个字符
console.log(str.substr(3, 7));  // "lo worl" - 从第三位开始截取长度为 7 的字符串
```

#### 2. 参数为负

```javascript
let stringValue = "hello world";

console.log(stringValue.slice(-3)); // "rld" - 从倒数第三位开始截取
console.log(stringValue.substring(-3)); // "hello world" - 从第 0 位开始截取到最后
console.log(stringValue.substr(-3)); // "rld" - 从倒数第三位开始截取

console.log(stringValue.slice(3, -4)); // "lo w" - 从第三位开始截取，到倒数第四位
console.log(stringValue.substring(3, -4));  // "hel" - 从第三位开始截取，截取到 0 位 (-4 被转为 0)
console.log(stringValue.substr(3, -4));     // ""  - 从第三位开始截取，截取 0 个字符串，所以为空
```

## ➣ == 和 === 区别

如果对比双方的类型不一样的话，== 会触发 js 数据的隐式转换规则用于对比两个值是否相等；而 === 是全等符号，只有两个比较值完全相等时才会返回 true，对于基本类型来说，会直接比较值是否相等，对于引用对象来说，会比较引用地址是否相等。

值得注意的是 `NaN` 非合法数值互不相等，也就是 `NaN !== NaN`。


== 进行隐式转换时会进行如下判断流程：

- 首先会判断两者类型是否相同，相同的话就是比大小了。
- 类型不相同的话，那么就会进行类型转换。
- 会先判断是否在对比 null 和 undefined，是的话就会返回 true。
- 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number。
  ```javascript
  1 == '1'
        ↓
  1 ==  1
  ```
- 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断。
  ```javascript
  '1' == true
          ↓
  '1' ==  1
          ↓
   1  ==  1
  ```
- 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断。
  ```javascript
    '1' == {name: 'yck'}
            ↓
    '1' == '[object Object]'
  ```

速记图：

![](https://nojsja.gitee.io/static-resources/images/interview/==.png)

## ➣ ES6 新增特性

1. Promise
2. let/const / 块级作用域
3. Arrow Function、函数默认参数、数组、对象、函数返回值的解构
4. Map/WeakMap/Set/WeakSet
5. ES6 Class
6. 字符串方法扩展 repeat/trim/includes/startsWith/endsWith/padStart/padEnd
7. 数组方法扩展 find/findIndex/fill/includes
8. Array.from 将类数组和实现了迭代器的对象转换成数组
9. Array.of 将一个或多个值转换成数组

## ➣ 浏览器上的线程和进程

##### 1. 浏览器包含下面几种进程：

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个。
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
- GPU 进程：最多一个，用于 3D 绘制等。
- 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。

##### 2. 浏览器渲染进程是多线程的，包括以下线程：

- GUI 渲染线程
负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
当界面需要重绘（Repaint）或由于某种操作引发回流 (reflow) 时，该线程就会执行
GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

- JS 引擎线程
也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
JS 引擎线程负责解析 Javascript 脚本，运行代码。
JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

- 事件触发线程
归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程, 如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

- 定时触发器线程
传说中的 setInterval 与 setTimeout 所在线程
浏览器定时计数器并不是由 JavaScript 引擎计数的, （因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

- 异步 http 请求线程
在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## ➣ EventLoop 事件循环

![](http://nojsja.gitee.io/static-resources/images/interview/browser_eventloop.png)

JavaScript 是用于实现网页交互逻辑的，涉及到 dom 操作，如果多个线程同时操作需要做同步互斥的处理，为了简化就设计成了单线程，但是如果单线程的话，遇到定时逻辑、网络请求又会阻塞住。怎么办呢？
可以加一层调度逻辑。把 JS 代码封装成一个个的任务，放在一个任务队列中，主线程就不断的取任务执行就好了。
每次取任务执行，都会创建新的调用栈。

其中，定时器、网络请求其实都是在别的线程执行的，执行完了之后在任务队列里放个任务，告诉主线程可以继续往下执行了。

因为这些异步任务是在别的线程执行完，然后通过任务队列通知下主线程，是一种事件机制，所以这个循环叫做 Event Loop。
这些在其他线程执行的异步任务包括定时器（setTimeout、setInterval），UI 渲染、网络请求（XHR 或 fetch）。
但是，现在的 Event Loop 有个严重的问题，没有优先级的概念，只是按照先后顺序来执行，那如果有高优先级的任务就得不到及时的执行了。所以，得设计一套插队机制。
那就搞一个高优先级的任务队列就好了，每执行完一个普通任务，都去把所有高优先级的任务给执行完，之后再去执行普通任务。

有了插队机制之后，高优任务就能得到及时的执行。
这就是现在浏览器的 Event Loop。
其中普通任务叫做 MacroTask（宏任务），高优任务叫做 MicroTask（微任务）。

宏任务包括：

- script 标签的代码。
- setTimeout、setInterval
- requestAnimationFrame
- Ajax
- fetch

微任务包括：

- Promise.then
- MutationObserver
- Object.observe(已经废弃，建议使用 Proxy)。

怎么理解宏微任务的划分呢？
定时器、网络请求这种都是在别的线程跑完之后通知主线程的普通异步逻辑，所以都是宏任务。

而高优任务的这三种也很好理解，MutationObserver 和 Object.observe 都是监听某个对象的变化的，变化是很瞬时的事情，肯定要马上响应，不然可能又变了，Promise 是组织异步流程的，异步结束调用 then 也是很高优的。

这就是浏览器里的 Event Loop 的设计：设计 Loop 机制和 Task 队列是为了支持异步，解决逻辑执行阻塞主线程的问题，设计 MicroTask 队列的插队机制是为了解决高优任务尽早执行的问题。

## ➣ Js 和 V8 垃圾回收机制

#### 1. 垃圾回收基础算法

##### I. 引用计数算法

核心思想：在内部设置一个引用计数器，当每个对象空间的引用关系发生变化时，修改计数器的数值。当某个对象空间的引用数为 0 时，
会立即触发垃圾回收机制，对这个对象空间进行回收。
复制代码
引用计数算法出现在早期的实现中，现在已经很少被用到。但我们依然可以通过学习这种算法，了解它的思想。下面举个例子来说明：
```js
let obj = {name:'zhangsan'} // 对象 zhangsan 被 obj 引用了一次
let obj2 = obj1 // 对象 zhangsan 被第二次引用，计数器值为 2

obj = null // 解除 obj 到对象 zhangsan 的引用，zhangsan 的引用计数器值变为 1
obj2 = null // 此时对象 zhangsan 的引用变为 0，堆内存中存储 zhangsan 的空间将被当成垃圾回收
```

引用计数算法优缺点说明

- 优点：由于引用计数算法实时监控着内存空间的引用数，当引用数为 0 时，能立即回收该内存空间，引用计数算法能最大程度减少程序的暂停。

- 缺点：由于引用计数算法维护着一个计数器，它要时刻监控该数值是否需要修改，因此时间开销较大。它也不能解决循环引用的问题。

所谓的循环引用，可以用一个例子说明：

```javascript
let obj1={value:obj2}
let obj2={value:obj1}
// 这样就构成了一对循环引用。即使 obj1 和 obj2 所代表的对象空间在其他地方再没有被引用到，
// 由于他们互相引用，这两个内存空间也不会被销毁。
```

##### II. 标记清除算法

核心思想：将垃圾回收过程分为 标记 和 清除 两个阶段。在标记阶段，从根对象（全局对象）出发遍历所有对象，将所有可达对象
做上标记。在清除阶段，同样会遍历所有对象，对没有标记的对象进行清除操作。
复制代码
这段定义里有两个关键概念：根对象 和 可达对象，下面依次给出解释：

根对象：在 JavaScript 中可以认为是全局对象
可达对象：从根对象出发，能够通过层层引用被访问到的对象。

好比全局对象上定义了一个变量 obj1, 其内部属性 value 指向了另一个对象 obj2, 在 obj2 中，又引用了 obj3。在这条引用链上的所有对象，obj1,obj2,obj3 都是可达对象，反之，如果某个对象不能通过根对象的引用找到，则为不可达对象，其内存空间将被当做垃圾回收。

标记清除算法优缺点说明

- 优点：可以回收循环引用的对象。
- 缺点：容易产生碎片化空间，浪费空间；不会立即回收垃圾对象。

##### III. 标记整理算法

标记整理算法是一种运用于 v8 引擎中的 GC 算法，它可以看做是标记清除算法的升级版。
标记整理算法分为 标记 和 整理 两个阶段。其中的标记阶段和 标记清除 算法相同，都是将所有可达对象做上标记。
在整理阶段，将所有标记过的可达对象在内存空间上进行移动，使其占有连续的内存空间。

#### 2. V8 的垃圾回收机制

V8 引擎是 chrome 浏览器内部和 Node 的 JS 执行引擎，其特性是运行高效，即时编译，并且内存设置了上限

对 64 位操作系统上： 上限大约为 1.5G
对 32 位操作系统上： 上限大约为 800M

V8 引擎的垃圾回收采用了 分代回收 的回收策略
在 V8 内部，把内存空间分成了新生代和老生代区域, 针对不同代采用不同的 GC 算法

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc1.png)

其中新生代区域空间较小，在 64 位操作系统上为 32M, 在 32 位操作系统上为 16M，其中保存着存活时间较短的对象。
v8 将新生代空间均分为两个等大空间，使用中的空间称为 from, 空闲的空间称为 to。当 from 空间使用达到一定上限，就会触发垃圾回收机制。V8 新生代的垃圾回收采用的是 Scavenge 策略。

##### I. 新生代对象回收实现

1. 标记阶段

将 from 空间中的活跃对象（使用中对象）进行标记，识别出等待回收的对象

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc2.png)

2. 排序整理阶段

将 from 空间中的活跃对象拷贝到 to 空间中

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc3.png)

将 from 空间完全释放

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc4.png)
3. 交换阶段

将 from 空间和 to 空间进行互换，完成本次垃圾回收操作。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc5.png)

与新生代区域不同，老生代区域存放的是活动时间较长的对象，比如全局对象、闭包等。
与新生代区域一样，老生代内存区同样也存在大小限制，和进行垃圾回收的特有策略
在 64 位操作系统中，老生代内存的存储上限是 1.4G
在 32 位操作系统中，老生代内存代存储上限是 700M

1. 新生代对象向老生代晋升

当新生代中一个对象多次出现在 to 空间里，或者当 to 空间内存超过 25% 时，该对象会被移入老生代空间。这种操作被成为晋升。

默认情况下，程序生成的对象会首先被放置在 from 空间中。当进行垃圾回收，将对象们从 from 移至 to 时，会通过检查该对象的内存地址来判断该对象是否已经经历过一次 Scavenge 运算，如果是，则将该对象移至老生代空间。接下来，判断 to 空间是否超过 25%, 如果是，则仍将该对象移至老生代空间。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc6.png)

##### II. 老生代对象回收实现

新生代对象中之所以能使用 Scavenge 算法这种利用空间来交换时间的算法，是因为新生代对象存储空间本身比较小，即使被一分为二，损失的存储空间也很有限。相比新生代的这种策略，老生代对象的存储空间更大，使用分代回收的话将会损失很大的存储空间，得不偿失。另外，由于老生代内存存储了大量对象，用这种算法复制对象，会使效率大幅降低。

因此，老生代内存的垃圾回收，采用了与新生代不同的策略。具体来说，主要有标记清除 (mark-sweep) 和标记整理 (mark-compact) 两种算法。没错，就是文章前面提到的两种基本算法。
在此，我们用图示进一步说明这两种算法：

(1) 标记清除算法在老生代空间内的应用：

- 开始阶段，其中 ABCDEF 为已使用内存

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc7.png)

- 标记阶段，其中 ACE 为活跃对象，其余为待清除对象

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc8.png)

- 清除阶段，将待清除对象的空间释放

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc9.png)

由以上图示不难发现，标记清除算法在每次清除过后，内存会出现不连续的状态。后续继续在老生代空间里分配内存时，如果需要分配一个大内存，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。

因此，在标记清除算法的基础上，又发展出标记整理算法。标记整理算法在标记阶段和清除算法是一样的。不同的是，在标记完活跃对象后，会将活跃对象移动到堆内存的另一端，然后将边界外的内存全部清除。

(2) 标记清除算法在老生代空间内的应用：

- 标记阶段，和标记清除算法一致。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc10.png)

- 整理阶段，将活跃对象拷贝直堆内存的另一端

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc11.png)

- 清除阶段，将拷贝对象边界外的内存清空

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc12.png)

(3) 标记清除算法和标记整理算法的结合使用

在取舍上，由于标记整理算法需要移动对象，所以速度不会很快；因此，老生代算法主要采用标记清除，当新生代晋升过来的对象大小大于老生代可用空间时，才启动标记整理算法。

#### 3. 总结

以上就是关于 JS 垃圾回收机制的内容。总的来说，JavaScript 中存在多种 GC 算法，在 V8 引擎中，主要利用了标记清除、标记整理和 scavenge 算法，分别对新生代和老生代内存进行垃圾回收。

其中新生代采用 scavenge 算法，利用空间的损失换取时间上的优势。

老生代混合采用标记清除和标记整理算法，对保存至老生代空间的对象进行回收。

新生代空间内的对象满足一定条件，可用晋升至老生代空间。

另外在老版本的 js 引擎中，还使用过引用计数算法，目前已经不再使用。

## ➣ 作用域

### 1. 定义

作用域产生于程序源代码中定义变量的区域，在程序编码阶段就确定了。javascript 中分为全局作用域 (Global Context： `window`/`global`) 和局部作用域（Local Context）。作用域也可以指代 ` 生成环境 ` 或者 ` 上下文 `，包含了当前区域内定义的变量以及对外层作用域的引用。

### 2. 类别

| 作用域（Scope） | -   |
| --- | --- |
| window/global Scope | 全局作用域 |
| function Scope | 函数作用域 |
| Block Scope | 块作用域（ES6） |
| eval Scope | eval 作用域（影响性能） |
| with Scope | with 作用域 （影响性能）|

#### 1）window/global 全局作用域

window 和 global 都是全局作用域，他们是作用域链的根，作用域查找的全局作用域之后就无法再向上查找了。全局作用域内声明过多的变量和函数会影响性能，应该尽量减少全局变量的声明。

#### 2）function 函数作用域

ES5 函数作用域即函数运行过程中创建的函数内部独立的上下文，它包含了函数内声明的变量。函数作用域内部仍然可以再创建函数作用域，作用域之间会以内外包含的方式存在。在进行变量查找时引擎会以词法声明的规则沿着作用域链进行向上查找，而不是进行动态查找，因此它和函数的调用位置无关，只和函数的声明位置有关。

- x 输出结果是 10，Js 采用静态作用域查找，跟说函数在哪里执行无关。

```javascript
var x = 10;
function fn() {
  console.log(x); // 输出 10
}
fn();
function show(fun) {
  var x = 20;
  fun();
}
show(fn);
```

#### 3）ES6 块作用域

ES6 中 一对 "{...}" 即被视为一个块级作用域，常见的 `if/for/while/switch` 等语句块都可以创建块级作用域。

ES6 中 `let/const` 均享有块级作用域规则，块级作用域内变量声明不会被提升，并且块级作用域内部的变量不能被外部访问，并且内部变量会 "遮蔽" 外部同名变量。

```javascript
function test() {
    let a = 1;
    if(true){
      let a = 10;
      console.log(a);  // 输出：10
    }
    console.log(a);   // 输出：1
}

test();  // 调用函数
```

在 ES5 中规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。而在 ES6 中引入了块级作用域，允许函数在块级作用域中声明。块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。

```javascript
{
    if(true){
        function test(){
            console.log("xxx")
        }
    }
}

test();
```

#### 4）eval 作用域

JavaScript 中的 eval(..) 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。

在 eval(..)被执行的后续代码行中，引擎 将不会 “知道” 或 “关心” 前面的代码是被动态翻译的，而且因此修改了词法作用域环境。引擎 将会像它一直做的那样，简单地进行词法作用域查询。

eval(…) 可以 '欺骗' 词法作用域，前者可以通过对一个拥有一个或多个声明的 “代码” 字符串进行求值，来（在运行时）修改现存的词法作用域，__会对引擎的性能有一定影响__。

```javascript
var b = 2;
function demo(str, a) {
  // 'use strict' - 严格模式可以忽略 eval 对词法作用域的影响，仍然输出 1, 2
  eval(str);           // 欺骗词法作用域
  console.log(a, b);
}
demo("var b = 12;", 1); // 1, 12
```

#### 5）with 作用域

with 语句接收一个对象，这个对象有 0 个或多个属性，并 将这个对象视为好像它是一个完全隔离的词法作用域，因此这个对象的属性被视为在这个 “作用域” 中词法定义的标识符。

通过将一个对象引用看作一个 “作用域”，并将这个对象的属性看作作用域中的标识符，也是在运行时创建一个全新的词法作用域，__会对引擎的性能有一定影响__。

另外，使用 with 时，容易把变量泄露到全局，造成全局变量污染。

```javascript
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2 -- 哦，全局作用域被泄露
```

### 3. 访问规则

关键词：

- 词法作用域 (Lexical Scope)
- 作用域链 (Scope Chain)

Js 遵循词法作用域规范 (静态作用域)，即词法阶段确定作用域 Scope。也就是说，Js 作用域是根据源代码中变量和块的位置，在词法分析器处理源代码时生成的。

作用域之间可以相互嵌套，形成作用域链。在当前作用域内的查找变量时会从当前作用域开始，依次向上查找，直到找到为止。

所以作用域确定了当前上下文内定义的变量的可见性，即子作用域可以访问到当前作用域内属性、函数。而作用域链（Scope Chain）也确定了在当前上下文中查找标识符后返回的值。

## ➣ 为什么 0.1 + 0.2 != 0.3

先说原因，因为 JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。

我们都知道计算机是通过二进制来存储东西的，那么 0.1 在二进制中会表示为：

```javascript
// (0011) 表示循环
0.1 = 0.00011(0011) = 2^-4 * 1.10011(0011)
```

我们可以发现，0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

IEEE 754 双精度版本（64 位）将 64 位分为了三段：

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011)

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002。

```javascript
0.100000000000000002 === 0.1 // true
```

那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002

```javascript
0.200000000000000002 === 0.2 // true
```

所以这两者相加不等于 0.3 而是 0.300000000000000004

```javascript
0.1 + 0.2 === 0.30000000000000004 // true
```

那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

console.log(0.100000000000000002) // 0.1

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题。

```javascript
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```