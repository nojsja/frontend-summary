---
lang: zh-CN
title: 基础知识
description: Javascript 的描述
---

### > 基本数据类型和引用数据类型

1. 基本数据类型：String/Boolean/Number/Null/Undefined/Symbol/BigInt(ES2020)
2. 引用数据类型：Function/Object/Array

### > ES6新增特性

1. Promise
2. let/const/块级作用域
3. Arrow Function、函数默认参数、数组、对象、函数返回值的解构
4. Map/WeakMap/Set/WeakSet
5. ES6 Class
6. 字符串方法扩展repeat/trim/includes/startsWith/endsWith/padStart/padEnd
7. 数组方法扩展find/findIndex/fill/includes
8. Array.from将类数组和实现了迭代器的对象转换成数组
9. Array.of将一个或多个值转换成数组

### > 浏览器上的线程和进程

##### 1. 浏览器包含下面几种进程：

  - Browser 进程：浏览器的主进程（负责协调、主控），只有一个。
  - 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
  - GPU 进程：最多一个，用于 3D 绘制等。
  - 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。

##### 2. 浏览器渲染进程是多线程的，包括以下线程：

- GUI 渲染线程  
负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

- JS 引擎线程  
也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
JS 引擎线程负责解析 Javascript 脚本，运行代码。
JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

- 事件触发线程  
归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程, 如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

- 定时触发器线程  
传说中的 setInterval 与 setTimeout 所在线程
浏览器定时计数器并不是由 JavaScript 引擎计数的, （因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

- 异步 http 请求线程  
在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

### > EventLoop 事件循环

![](http://nojsja.gitee.io/static-resources/images/interview/browser_eventloop.png)

JavaScript 是用于实现网页交互逻辑的，涉及到 dom 操作，如果多个线程同时操作需要做同步互斥的处理，为了简化就设计成了单线程，但是如果单线程的话，遇到定时逻辑、网络请求又会阻塞住。怎么办呢？
可以加一层调度逻辑。把 JS 代码封装成一个个的任务，放在一个任务队列中，主线程就不断的取任务执行就好了。
每次取任务执行，都会创建新的调用栈。

其中，定时器、网络请求其实都是在别的线程执行的，执行完了之后在任务队列里放个任务，告诉主线程可以继续往下执行了。

因为这些异步任务是在别的线程执行完，然后通过任务队列通知下主线程，是一种事件机制，所以这个循环叫做 Event Loop。
这些在其他线程执行的异步任务包括定时器（setTimeout、setInterval），UI 渲染、网络请求（XHR 或 fetch）。
但是，现在的 Event Loop 有个严重的问题，没有优先级的概念，只是按照先后顺序来执行，那如果有高优先级的任务就得不到及时的执行了。所以，得设计一套插队机制。
那就搞一个高优先级的任务队列就好了，每执行完一个普通任务，都去把所有高优先级的任务给执行完，之后再去执行普通任务。

有了插队机制之后，高优任务就能得到及时的执行。
这就是现在浏览器的 Event Loop。
其中普通任务叫做 MacroTask（宏任务），高优任务叫做 MicroTask（微任务）。

宏任务包括：

- script 标签的代码。
- setTimeout、setInterval
- requestAnimationFrame
- Ajax
- fetch

微任务包括：

- Promise.then
- MutationObserver
- Object.observe(已经废弃，建议使用 Proxy)。

怎么理解宏微任务的划分呢？
定时器、网络请求这种都是在别的线程跑完之后通知主线程的普通异步逻辑，所以都是宏任务。

而高优任务的这三种也很好理解，MutationObserver 和 Object.observe 都是监听某个对象的变化的，变化是很瞬时的事情，肯定要马上响应，不然可能又变了，Promise 是组织异步流程的，异步结束调用 then 也是很高优的。

这就是浏览器里的 Event Loop 的设计：设计 Loop 机制和 Task 队列是为了支持异步，解决逻辑执行阻塞主线程的问题，设计 MicroTask 队列的插队机制是为了解决高优任务尽早执行的问题。

### > Js 和 V8 垃圾回收机制

#### 1. 垃圾回收基础算法

##### I. 引用计数算法

核心思想：在内部设置一个引用计数器，当每个对象空间的引用关系发生变化时，修改计数器的数值。当某个对象空间的引用数为0时，
会立即触发垃圾回收机制，对这个对象空间进行回收。
复制代码
引用计数算法出现在早期的实现中，现在已经很少被用到。但我们依然可以通过学习这种算法，了解它的思想。下面举个例子来说明：
```js
let obj = {name:'zhangsan'} // 对象zhangsan被obj引用了一次
let obj2 = obj1 // 对象zhangsan被第二次引用，计数器值为2
    
obj = null // 解除obj到对象zhangsan的引用，zhangsan的引用计数器值变为1
obj2 = null // 此时对象zhangsan的引用变为0，堆内存中存储zhangsan的空间将被当成垃圾回收
```

引用计数算法优缺点说明

- 优点：由于引用计数算法实时监控着内存空间的引用数，当引用数为0时，能立即回收该内存空间，引用计数算法能最大程度减少程序的暂停。

- 缺点：由于引用计数算法维护着一个计数器，它要时刻监控该数值是否需要修改，因此时间开销较大。它也不能解决循环引用的问题。

所谓的循环引用，可以用一个例子说明：

```javascript
let obj1={value:obj2}
let obj2={value:obj1}
// 这样就构成了一对循环引用。即使obj1和obj2所代表的对象空间在其他地方再没有被引用到，
// 由于他们互相引用，这两个内存空间也不会被销毁。
```

##### II. 标记清除算法

核心思想：将垃圾回收过程分为 标记 和 清除 两个阶段。在标记阶段，从根对象（全局对象）出发遍历所有对象，将所有可达对象
做上标记。在清除阶段，同样会遍历所有对象，对没有标记的对象进行清除操作。
复制代码
这段定义里有两个关键概念：根对象 和 可达对象，下面依次给出解释：

根对象：在JavaScript中可以认为是全局对象
可达对象：从根对象出发，能够通过层层引用被访问到的对象。

好比全局对象上定义了一个变量obj1,其内部属性value指向了另一个对象obj2,在obj2中，又引用了obj3。在这条引用链上的所有对象，obj1,obj2,obj3都是可达对象，反之，如果某个对象不能通过根对象的引用找到，则为不可达对象，其内存空间将被当做垃圾回收。

标记清除算法优缺点说明

- 优点：可以回收循环引用的对象。
- 缺点：容易产生碎片化空间，浪费空间；不会立即回收垃圾对象，

##### III. 标记整理算法

标记整理算法是一种运用于v8引擎中的GC算法，它可以看做是标记清除算法的升级版。
标记整理算法分为 标记 和 整理 两个阶段。其中的标记阶段和 标记清除 算法相同，都是将所有可达对象做上标记。
在整理阶段，将所有标记过的可达对象在内存空间上进行移动，使其占有连续的内存空间。

#### 2. V8 的垃圾回收机制

V8引擎是chrome浏览器内部和Node的JS执行引擎，其特性是运行高效，即时编译，并且内存设置了上限

对64位操作系统上： 上限大约为1.5G
对32位操作系统上： 上限大约为800M

V8引擎的垃圾回收采用了 分代回收 的回收策略
在V8内部，把内存空间分成了新生代和老生代区域,针对不同代采用不同的GC算法

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc1.png)

其中新生代区域空间较小，在64位操作系统上为32M,在32位操作系统上为16M，其中保存着存活时间较短的对象。
v8将新生代空间均分为两个等大空间，使用中的空间称为from,空闲的空间称为to。当from空间使用达到一定上限，就会触发垃圾回收机制。V8新生代的垃圾回收采用的是Scavenge策略。

##### I. 新生代对象回收实现

1. 标记阶段

将from空间中的活跃对象（使用中对象）进行标记，识别出等待回收的对象

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc2.png)

2. 排序整理阶段

将from空间中的活跃对象拷贝到to空间中

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc3.png)

将from空间完全释放

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc4.png)
3. 交换阶段

将from空间和to空间进行互换，完成本次垃圾回收操作。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc5.png)

与新生代区域不同，老生代区域存放的是活动时间较长的对象，比如全局对象、闭包等。
与新生代区域一样，老生代内存区同样也存在大小限制，和进行垃圾回收的特有策略
在64位操作系统中，老生代内存的存储上限是1.4G
在32位操作系统中，老生代内存代存储上限是700M

1. 新生代对象向老生代晋升

当新生代中一个对象多次出现在to空间里，或者当to空间内存超过25%时，该对象会被移入老生代空间。这种操作被成为晋升。

默认情况下，程序生成的对象会首先被放置在from空间中。当进行垃圾回收，将对象们从from移至to时，会通过检查该对象的内存地址来判断该对象是否已经经历过一次Scavenge运算，如果是，则将该对象移至老生代空间。接下来，判断to空间是否超过25%,如果是，则仍将该对象移至老生代空间。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc6.png)

##### II. 老生代对象回收实现

新生代对象中之所以能使用Scavenge算法这种利用空间来交换时间的算法，是因为新生代对象存储空间本身比较小，即使被一分为二，损失的存储空间也很有限。相比新生代的这种策略，老生代对象的存储空间更大，使用分代回收的话将会损失很大的存储空间，得不偿失。另外，由于老生代内存存储了大量对象，用这种算法复制对象，会使效率大幅降低。

因此，老生代内存的垃圾回收，采用了与新生代不同的策略。具体来说，主要有标记清除(mark-sweep)和标记整理(mark-compact)两种算法。没错，就是文章前面提到的两种基本算法。
在此，我们用图示进一步说明这两种算法：

(1) 标记清除算法在老生代空间内的应用：

- 开始阶段，其中ABCDEF为已使用内存

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc7.png)

- 标记阶段，其中ACE为活跃对象，其余为待清除对象

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc8.png)

- 清除阶段，将待清除对象的空间释放

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc9.png)

由以上图示不难发现，标记清除算法在每次清除过后，内存会出现不连续的状态。后续继续在老生代空间里分配内存时，如果需要分配一个大内存，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。

因此，在标记清除算法的基础上，又发展出标记整理算法。标记整理算法在标记阶段和清除算法是一样的。不同的是，在标记完活跃对象后，会将活跃对象移动到堆内存的另一端，然后将边界外的内存全部清除。

(2) 标记清除算法在老生代空间内的应用：

- 标记阶段，和标记清除算法一致。

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc10.png)

- 整理阶段，将活跃对象拷贝直堆内存的另一端

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc11.png)

- 清除阶段，将拷贝对象边界外的内存清空

![gc](http://nojsja.gitee.io/static-resources/images/interview/gc12.png)

(3) 标记清除算法和标记整理算法的结合使用

在取舍上，由于标记整理算法需要移动对象，所以速度不会很快；因此，老生代算法主要采用标记清除，当新生代晋升过来的对象大小大于老生代可用空间时，才启动标记整理算法。

#### 3. 总结

以上就是关于JS垃圾回收机制的内容。总的来说，JavaScript中存在多种GC算法，在V8引擎中，主要利用了标记清除、标记整理和scavenge算法，分别对新生代和老生代内存进行垃圾回收。

其中新生代采用scavenge算法，利用空间的损失换取时间上的优势。

老生代混合采用标记清除和标记整理算法，对保存至老生代空间的对象进行回收。

新生代空间内的对象满足一定条件，可用晋升至老生代空间。

另外在老版本的js引擎中，还使用过引用计数算法，目前已经不再使用。