---
lang: zh-CN
title: ● 基础知识
description: Network & System 的描述
---

## ➣ cpu 调度算法

## ➣ 并发（concurrency）和并行（parallelism）区别

异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。

## ➣ 什么是堆？什么是栈？它们之间有什么区别和联系？

### 一、数据结构中的堆和栈

堆：

数据结构中堆是满足父子节点大小（比如大根堆中规定父节点的值要比子节点大）关系的一种完全二叉树（完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边）。

由于是完全二叉树，可以用数组来实现，用节点编号来访问和操作节点，简化程序，提升效率。而其大小关系则为我们查询堆中极值提供了常数级别的时间复杂度，又由二叉树的性质，插入和删除则为对数级别时间复杂度。这就好像地位不同的人在排队，排在最前面的一定是地位最高的人，所以堆是优先队列（Priority Queue）实现的基础。利用这一特性，可以加速某些需要频繁取队列中极值的算法比如 A* 算法等。

栈：

数据结构中的栈则是一种相当简单的结构。就像是只有一个口的深深的文件桶，先进去的文件会被压在下面（push），而且我们每次只能取到最上面的文件（pop），体现了其先进后出（FILO）的特性。虽然栈操作简单，但也有如单调栈等在栈内保持一定数据特性的变种。

### 二、操作系统中的堆和栈

堆：

操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。

__内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存__，即使是同一个程序也可能占用了不同地方的多块内存。操作系统中则会对这些空间进行统一的管理，在应用程序提出申请时，就会从堆中按照一定算法找出一块可用内存，标记占用空间等信息之后返回其起始地址给程序。在程序结束之前，操作系统不会删除已经申请的内存，而是要靠程序主动提出释放的请求（free、delete），如果使用后忘记释放，就会造成所谓的内存泄漏问题。__因此堆基本上可以理解为当前可以使用的空闲内存，但是其申请和释放都要程序员自己写代码管理__。

栈：

__而操作系统的栈则是程序运行时自动拥有的一小块内存，大小在编译期时由编译器参数决定，用于局部变量的存放或者函数调用栈的保存__。在 C 中如果声明一个局部变量（例如 int a），它存放的地方就在栈中，而当这个局部变量离开其作用域之后，所占用的内存则会被自动释放，因此在 C 中局部变量也叫自动变量。

栈的另一个作用则是保存函数调用栈，这时和数据结构的栈就有关系了。在函数调用过程中，常常会多层甚至递归调用。每一个函数调用都有各自的局部变量值和返回值，每一次函数调用其实是先将当前函数的状态压栈，然后在栈顶开辟新空间用于保存新的函数状态，接下来才是函数执行。

当函数执行完毕之后，栈先进后出的特性使得后调用的函数先返回，这样可以保证返回值的有序传递，也保证函数现场可以按顺序恢复。__操作系统的栈在内存中高地址向低地址增长__，也即低地址为栈顶，高地址为栈底。这就导致了栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把你的程序杀掉。

## ➣ TCP 和 UDP 协议的区别

#### 一、TCP 协议

TCP 协议隶属于 TCP/IP 协议簇中的一个重要协议，它位于传输层。

TCP 协议是面向连接的，是一种可靠的传输协议。客户端和服务端开始通信之前需要通过三次握手保证连接正常建立，并确定连接双方都可正常收发消息。

__简述三次握手的过程：__

> SYN 这个标志位只有在 TCP 建立连接时才会被置 1 , 握手完成后 SYN 标志位被置 0。

- i. 第一次握手：主机 A 通过向主机 B 发送一个含有同步序列号的标志位的数据段给主机 B，向主机 B 请求建立连接，通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。
- ii. 第二次握手：主机 B 收到主机 A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我
- iii. 第三次握手：主机 A 收到这个数据段后，再发送一个确认应答，确认已收到主机 B 的数据段：" 我已收到回复，我现在要开始传输实际数据了，这样 3 次握手就完成了，主机 A 和主机 B 就可以传输数据了。

__简述四次挥手的过程：__

- i. 第一次：当主机 A 完成数据传输后，将控制位 FIN 置 1，提出停止 TCP 连接的请求；
- ii. 第二次：主机 B 收到 FIN 后对其作出响应，然后将这一方向上的 TCP 消息接收通道将关闭，将 ACK 置为 1；
- iii. 第三次：B 端最后的数据传输完成后，由 B 端再发出反方向的关闭请求，将 FIN 置 1；
- iv. 第四次：主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束；

字段说明：

- ACK 是 TCP 报头的控制位之一，对数据进行确认。确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为 X，则表示前 X-1 个数据段都收到了，只有当 ACK=1 时, 确认号才有效，当 ACK=0 时，确认号无效，这时会要求重传数据，保证数据的完整性。
- SYN 同步序列号，TCP 建立连接时将这个位置 1。
- FIN 发送端完成发送任务位，当 TCP 完成数据传输需要断开时,，提出断开连接的一方将这位置 1。

__TCP 协议的包头结构__

![](https://nojsja.gitee.io/static-resources/images/interview/tcp-protocol.png)

源端口 16 位；目标端口 16 位；序列号 32 位；回应序号 32 位；TCP 头长度 4 位；reserved 保留 6 位；控制代码 6 位；窗口大小 16 位；偏移量 16 位；校验和 16 位；选项 32 位 (可选)；

这样我们得出了 TCP 包头的最小长度，为 20 字节。

#### 二、UDP 协议


UDP 协议 (用户数据报协议) 是面向报文的，是一种非可靠协议，位于传输层，传输数据之前源端和终端不建立连接。

它适用于一些低精度的通信场景，比如网络直播，丢失了一两帧的数据，但是数据通信的性能得到了提升。

UDP 信息包头很短，只有 8 个字节。UDP 传送数据的速度仅仅是受应用程序生成数据的速度、计算机的性能和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文， 在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

__UDP 的包头结构：__

![](https://nojsja.gitee.io/static-resources/images/interview/udp-protocol.jpg)

源端口 16 位；目的端口 16 位；UDP 长度 16 位；校验和 16 位

#### 三、总结

1. 基于连接与无连接；
2. 对系统资源的要求（TCP 较多，UDP 少）；
3. UDP 程序结构较简单；
4. 流模式与数据报模式；
5. TCP 保证数据正确性，UDP 可能丢包；
6. TCP 保证数据顺序，UDP 不保证；

## ➣ 浏览器缓存
### 1. 浏览器缓存的工作流程

&nbsp;&nbsp;&nbsp;&nbsp; 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

&nbsp;&nbsp;&nbsp;&nbsp; 这里先看张大家最熟悉的 Devtools 网络图：

![](http://nojsja.gitee.io/static-resources/images/http/network.png)

图中青色、绿色和橙色圈出的部分分别是来自内存 (memory 缓存)、磁盘(disk 缓存) 和 Http 请求拿到的数据 (非缓存)，还有一种返回码 304 的请求也是从缓存(memory/disk) 中获取数据。304 跟 memory/disk 缓存的区别是：在浏览器判断资源已经过期的情况下会去服务器查询资源是否更新，如果资源没更新则返回 304 码，浏览器收到 304 码就会更新资源的过期时间并直接从之前 disk/memory 缓存中拿到当前资源，换言之如果资源没过期，那么浏览器就会跳过向服务器校验资源这一步并直接去拿 memory/disk 缓存获取。

![](http://nojsja.gitee.io/static-resources/images/http/http_cache2.png)

大致流程如下：

- 1）首先检查是否存在 Service Worker Cache，没命中或不存在则进行下一步

- 2）检查内存中是否存在资源，存在的话直接加载 (from memory - 200)。

- 3）如果内存没有，择取从硬盘获取，存在且没过期的话直接加载 (from disk - 200)，过期了直接向服务器发送请求获取资源。如果资源没更新，服务器返回 304，浏览器从硬盘缓存中获取资源，并更新 ` 过期时间 / Etag/Last-Modified`。如果资源更新了则获取最新的资源，并通过 HTTP 请求将资源返回，重新缓存资源并更新 ` 过期时间 / Etag/Last-Modified`。

- 4）如果硬盘也没有，那么会向后端发送 HTTP 网络请求。

- 5）加载到的资源缓存到硬盘和内存，并更新资源的 ` 过期时间 / Etag/Last-Modified`。

&nbsp;&nbsp;&nbsp;&nbsp; `Service Worker Cache` 具有较高的优先级，数据控制更为复杂，操作自由度最高；`Memory Cache` 更多的强调了一种缓存存储方式和浏览器内存缓存策略；`HTTP Cache` 相对于 `Memory Cache` 根据存储方式的不同也能叫做 `Disk Cache`，它依赖于整个 HTTP 缓存校验流程 (强缓存和协商缓存)，并通过校验来最终确定何时从缓存读取，何时从服务器更新资源；Push Cache 资料较少，应用得不多，暂时只做介绍。

### 2. Service-Worker Cache(优先级最高)
---

&nbsp;&nbsp;&nbsp;&nbsp; Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

&nbsp;&nbsp;&nbsp;&nbsp; Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

&nbsp;&nbsp;&nbsp;&nbsp; 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### 3. Memory Cache(优先级次之)

&nbsp;&nbsp;&nbsp;&nbsp; Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经获取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。内存缓存在缓存资源时并不关心返回资源的 HTTP 响应头部 Cache-Control 是什么值，换句话说这是一种强依赖于浏览器本地内存管理策略的缓存方式，各个浏览器对内存缓存的处理方式也略有区别。

&nbsp;&nbsp;&nbsp;&nbsp; Memory Cache 遵循这些策略：
- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

### 4. * HTTP Cache(优先级次之)

&nbsp;&nbsp;&nbsp;&nbsp; HTTP 缓存根据工作方式分为 ` 强缓存 ` 和 ` 协商缓存 `，浏览器首先会判断 ` 强缓存 ` 是否命中，命中失败才会尝试进行 ` 协商缓存 `。

![](http://nojsja.gitee.io/static-resources/images/http/http_cache.png)

1）强缓存

- \> HTTP 1.0 时代 - expires
&nbsp;&nbsp;&nbsp;&nbsp; 我们通过浏览器获取服务器远程资源时，服务器通过 http 请求 response headers 返回一个 `expires` 时间戳字段 (上图中蓝色部分)，例如 `expires: Wed, 13 Oct 2021 22:15:05 GMT`，表明这个资源的过期时间为格林威治时间 `2021 年 10 月 13 日 周三 22:15:05`(北京时间 + 8h = 格林威治时间)，浏览器判断当前时间在资源过期时间之前的话，就会从缓存中去读取资源 (如果缓存中存在的话)，否则会重新向服务器发送请求。
&nbsp;&nbsp;&nbsp;&nbsp; expires 的工作机制要求客户端时间与服务器时间误差较小，否则缓存更新策略可能在短时间不生效。

- \> HTTP 1.1 时代 - cache-control
&nbsp;&nbsp;&nbsp;&nbsp; `cache-control: max-age` 方式也是通过服务器返回资源时携带的 response headers 中的相应字段实现的，比如：`cache-control: max-age=31536000`，表明资源距浏览器接收到此资源后的 31536000 秒后过期。与 `expires` 返回的时间戳方式不同，cache-control 为了避免时间误差，直接返回一个时间长度，浏览器可以根据一个本地时间差值进行精确判断。
`cache-control` 其它相关字段还有：
&nbsp;&nbsp;&nbsp;&nbsp; __i.__ __public/private__：在依赖各种代理的大型架构中，我们不得不考虑代理服务器的缓存问题，public 与 private 用来控制代理服务缓存是否能缓存资源。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值，不过在只设置 s-maxage 的情况下，代理缓存也能生效。
&nbsp;&nbsp;&nbsp;&nbsp; __ii.__ __s-maxage__：针对于代理服务器的缓存问题，此字段用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，只对 public 缓存有效，`cache-control: max-age=3600, s-maxage=31536000`。
&nbsp;&nbsp;&nbsp;&nbsp; __iii.__ __no-cache__：为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期，直接进行 ` 协商缓存 `。
&nbsp;&nbsp;&nbsp;&nbsp; __iv.__ __no-store__：不使用任何缓存策略，每次请求都直接从服务器获取，并在浏览器客户端不进行资源缓存。

- \> cache-control 和 expires 并存
&nbsp;&nbsp;&nbsp;&nbsp; cache-control 的优先级更高，当 cache-control 与 expires 同时出现时，以 cache-control 为准，不过考虑向下兼容性可以选择同时使用两种缓存策略。

2）协商缓存

&nbsp;&nbsp;&nbsp;&nbsp; 协商缓存依赖于服务端与浏览器之间的通信，在第一次获取资源时浏览器会存储 HTTP 请求的 response headers 字段：Last-Modified / Etag，当强缓存未命中的时候，它的值作为浏览器和服务器通信时携带的标志位用于判断资源是否过期，如果服务器判断资源过期的话就会重新下载资源，并更新相应标志位。如果判断资源未更新的话，会返回 304 状态码，浏览器就会复用客户端缓存资源。

- \> Last-Modified 和 If-Modified-Since 方式
&nbsp;&nbsp;&nbsp;&nbsp; `Last-Modified` 为随服务器端 HTTP 响应头部返回的时间戳标志，表示一个资源最近一次被更新的时间，客户端请求资源时添加上 request headers 字段 `If-Modified-Since`(值与 Last-Modified 相同) 用于服务器做校验判断资源是否更新，`Last-Modified: Wed, 13 Jan 2021 15:34:55 GMT`。
使用 Last-Modified 存在一些弊端：
&nbsp;&nbsp;&nbsp;&nbsp; __i. 命中失误 1：__ 当我们更新了服务器的某个资源文件，但其实际内容并未发生变化，其相应的资源更新时间戳会改变，浏览器端在服务端文件并未发生改变的情况下，仅仅通过时间戳这种判断方式也会导致资源被完全重新下载。
&nbsp;&nbsp;&nbsp;&nbsp; __ii. 命中失误 2：__ If-Modified-Since 只能检查到以秒为最小计量单位的时间差，感知不到 1s 以内的文件改动的情况，这会导致一些浏览器缓存更新不及时的情况。

- \> Etag 和 If-None-Match 方式
&nbsp;&nbsp;&nbsp;&nbsp; `Etag` 就是为了弥补 `Last-Modified` 的弊端而产生的新的协商缓存方式。Etag 为随服务器端 HTTP 请求头部返回的资源唯一标志，例如：`ETag: W/"2a3b-1602480f459"`，它根据资源内容而生成，可以精确感知资源的变动情况，即使多次更新，只要内容不变，Etag 值也是不会变化的。浏览器下一次请求此资源时，request headers 里就会带上一个值相同的名为 `if-None-Match` 的字段用于服务器对此资源做对比，`If-None-Match: W/"2a3b-1602480f459"`。

- \> `Etag` 在感知文件变化上比 `Last-Modified` 更加准确，优先级也更高，不过 `Etag` 的生成会消耗掉部分服务器的性能，它可以作为一种辅助协商缓存方式与前者相互配合使用。当 `Etag` 和 `Last-Modified` 同时存在时，以 `Etag` 为准。

### 5. Push Cache(优先级最低)

Push Cache 是指 HTTP2 在 server push 阶段存在的缓存：

- Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。

## ➣ Cookie 缓存

Web Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。

### 一、创建 Cookie

当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

```console
Set-Cookie: <cookie 名>=<cookie 值 >
```

### 二、Cookie 生命周期

- __会话期 Cookie__：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。
- __持久性 Cookie__：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

```console
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 三、Cookie 安全性

有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和 HttpOnly 属性：

- 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防中间者攻击。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。

- Js `document.cookie` API 无法访问带有 HttpOnly 属性的 cookie。此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。

- SameSite Cookie：Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。SameSite 有三个值：
  ```console
  Set-Cookie: key=value; SameSite=Strict
  ```
  - __None__：浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。
  - __Strict__：浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）
  - __Lax__：与 Strict 类似，但用户从外部站点导航至 URL 时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到 URL 时才会发送，如 link 链接。
