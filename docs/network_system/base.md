---
lang: zh-CN
title: ● 基础知识
description: Network & System 的描述
---

## ➣ cpu 调度算法

### 一、什么是 CPU 调度？

CPU 调度是确定哪个进程将拥有 CPU 以便在另一个进程处于保持状态时执行的过程。CPU 调度的主要任务是确保每当 CPU 保持空闲时，OS 至少选择就绪队列中可用的进程之一来执行。选择过程将由 CPU 调度程序执行。它选择内存中准备执行的进程之一。

### 二、调度类型

- 抢占式调度：在 “抢先式调度” 中，大多数任务都分配有其优先级。有时，即使较低优先级的任务仍在运行，在另一个较低优先级的任务之前运行具有较高优先级的任务也很重要。较低优先级的任务会保留一段时间，并在较高优先级的任务完成执行时恢复。

- 非抢占式调度：在这种调度方法中，已将 CPU 分配给特定的进程。使 CPU 保持繁忙的进程将通过切换上下文或终止来释放 CPU。这是可用于各种硬件平台的唯一方法。那是因为它不需要抢先式调度之类的特殊硬件（例如计时器）。

### 三、调度标准

#### 最大化

- CPU 利用率： CPU 利用率是操作系统需要确保 CPU 保持尽可能繁忙的主要任务。范围从 0 到 100％。但是，对于 RTOS，它的范围可以从低级系统的 40％到高级系统的 90％。
- 吞吐量：每单位时间完成其执行的进程数称为吞吐量。因此，当 CPU 忙于执行该进程时，此时正在完成工作，并且每单位时间完成的工作称为吞吐量。

#### 最小化

- 等待时间：等待时间是特定进程在就绪队列中需要等待的时间。
- 响应时间：这是从提交请求到产生第一个响应为止的时间。
- 周转时间：周转时间是执行特定过程的时间。它是等待进入内存，等待队列以及在 CPU 上执行所花费的总时间的计算。从流程提交时间到完成时间的时间就是周转时间。

### 四、调度算法

#### 1. 先来先服务（FCFS）

先到先得是FCFS的完整形式。它是最简单，最简单的CPU调度算法。在这种算法中，请求CPU的进程首先获得CPU分配。可以使用FIFO队列来管理此调度方法。

当流程进入就绪队列时，其PCB（流程控制块）与队列尾部链接。因此，当CPU空闲时，应在队列开始处将其分配给进程。

FCFS方法的特点：

- 它提供了非抢占式和抢占式调度算法。
- 作业总是按照先到先得的原则执行
- 它易于实现和使用。
- 但是，这种方法性能较差，并且一般的等待时间相当长。

#### 2. 最短作业优先（SJF）调度

SJF是（最短作业优先）的完整形式，是一种调度算法，在该算法中，应选择执行时间最短的进程来执行。此调度方法可以是抢占式或非抢占式。它显着减少了其他等待执行进程的平均等待时间。

特点：

- 它与每个作业作为一个时间单位相关联。
- 在这种方法中，当CPU可用时，将首先执行完成时间最短的下一个过程或作业。
- 它是通过非抢占策略实现的。
- 此算法方法对于批处理类型非常有用，在这种批处理中，等待作业完成并不重要。
- 它通过提供较短的作业来提高作业输出，该作业应首先执行，而这些作业通常具有较短的周转时间。

#### 3. 剩余时间最短（SRT）

剩余时间最短（Shortest Run Time）SRT即“最短剩余时间”，也称为SJF抢占式调度。在这种方法中，进程将分配给最接近完成任务的任务。此方法可防止较新的就绪状态进程保持较旧进程的完成。

SJF 特点：

- 此方法主要用于需要优先考虑短期作业的批处理环境中。
- 这不是在所需CPU时间未知的共享系统中实现它的理想方法。
- 与每个进程相关联，作为其下一个CPU突发的长度。因此，操作系统使用这些长度，这有助于在尽可能短的时间内安排进程。

#### 4. 基于优先级的调度

这是一种基于优先级调度进程的方法。在这种方法中，调度程序根据优先级选择要工作的任务。

优先级调度还可以帮助OS涉及优先级分配。应该首先执行优先级较高的流程，而优先级相同的作业应以循环方式或FCFS方式进行。可以根据内存需求，时间需求等确定优先级。

#### 5. 循环调度

轮询是最古老，最简单的调度算法。该算法的名称来自循环原则，其中每个人依次获得相等的份额。它主要用于多任务处理中的调度算法。这种算法方法有助于无饥饿地执行进程。

特点：

- 轮询是一种由时钟驱动的混合模型
- 时间片应为最小，这是为要处理的特定任务分配的。但是，对于不同的过程，它可能会有所不同。
- 这是一个实时系统，可在特定时限内响应事件。

#### 6. 多级队列调度

该算法将就绪队列分为多个单独的队列。在此方法中，基于进程的特定属性（例如进程优先级，内存大小等）将进程分配给队列。

但是，这不是独立的调度OS算法，因为它需要使用其他类型的算法来调度作业。

特点：

- 对于具有某些特征的流程，应维护多个队列。
- 每个队列可能有其单独的调度算法。
- 每个队列都有优先级。

## ➣ 并发（concurrency）和并行（parallelism）区别

异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。

## ➣ 什么是堆？什么是栈？它们之间有什么区别和联系？

### 一、数据结构中的堆和栈

#### 1. 堆

数据结构中堆是满足父子节点大小（比如大根堆中规定父节点的值要比子节点大）关系的一种完全二叉树（完全二叉树的形式是指除了最后一层之外，其他所有层的结点都是满的，而最后一层的所有结点都靠左边）。

由于是完全二叉树，可以用数组来实现，用节点编号来访问和操作节点，简化程序，提升效率。而其大小关系则为我们查询堆中极值提供了常数级别的时间复杂度，又由二叉树的性质，插入和删除则为对数级别时间复杂度。这就好像地位不同的人在排队，排在最前面的一定是地位最高的人，所以堆是优先队列（Priority Queue）实现的基础。利用这一特性，可以加速某些需要频繁取队列中极值的算法比如 A* 算法等。

#### 2. 栈

数据结构中的栈则是一种相当简单的结构。就像是只有一个口的深深的文件桶，先进去的文件会被压在下面（push），而且我们每次只能取到最上面的文件（pop），体现了其先进后出（FILO）的特性。虽然栈操作简单，但也有如单调栈等在栈内保持一定数据特性的变种。

### 二、操作系统中的堆和栈

#### 1. 堆

操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。

__内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存__，即使是同一个程序也可能占用了不同地方的多块内存。在堆内存分配时操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。在程序结束之前，操作系统不会删除已经申请的内存，而是要靠程序主动提出释放的请求（free、delete），如果使用后忘记释放，就会造成所谓的内存泄漏问题。__因此堆基本上可以理解为当前可以使用的空闲内存，但是其申请和释放都要程序员自己写代码管理__。

堆内存是向高地址扩展的数据结构，是不连续的内存区域。堆内存是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。

#### 2. 栈

__而操作系统的栈则是程序运行时自动拥有的一小块内存，大小在编译期时由编译器参数决定，用于局部变量的存放或者函数调用栈的保存__。在 C 中如果声明一个局部变量（例如 int a），它存放的地方就在栈中，而当这个局部变量离开其作用域之后，所占用的内存则会被自动释放，因此在 C 中局部变量也叫自动变量。

栈的另一个作用则是保存函数调用栈，这时和数据结构的栈就有关系了。在函数调用过程中，常常会多层甚至递归调用。每一个函数调用都有各自的局部变量值和返回值，每一次函数调用其实是先将当前函数的状态压栈，然后在栈顶开辟新空间用于保存新的函数状态，接下来才是函数执行。

当函数执行完毕之后，栈先进后出的特性使得后调用的函数先返回，这样可以保证返回值的有序传递，也保证函数现场可以按顺序恢复。__操作系统的栈在内存中高地址向低地址增长__，也即低地址为栈顶，高地址为栈底。这就导致了栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把你的程序杀掉。

## ➣ TCP 和 UDP 协议的区别

#### 一、TCP 协议

TCP 协议隶属于 TCP/IP 协议簇中的一个重要协议，它位于传输层。

TCP 协议是面向连接的，是一种可靠的传输协议。客户端和服务端开始通信之前需要通过三次握手保证连接正常建立，并确定连接双方都可正常收发消息。

__简述三次握手的过程：__

![](https://nojsja.gitee.io/static-resources/images/http/tcp-shakehands.png)

> SYN 这个标志位只有在 TCP 建立连接时才会被置 1 , 握手完成后 SYN 标志位被置 0。

- 第一次握手：主机 A 将 SYN 标志位置为1，并向主机 B 发送一个含有同步序列号 (seq = x) 的标志位的数据段给主机 B，向主机 B 请求建立连接。通过这个数据段，主机 A 告诉主机 B 两件事：我想要和你通信，你可以用哪个序列号作为起始数据段来回应我。
- 第二次握手：收到主机 A 的请求后，主机 B 将 SYN 和 ACK 标志位置为1，并用一个带有确认应答（ack，值为 x + 1）和同步序列号（seq = y）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了，你要用那个序列号作为起始数据段来回应我。
- 第三次握手：主机 A 收到这个来自B的数据段后，确认数据段的值。然后将 ACK 标志位置为1，再发送一个确认应答（ack，值为 y + 1），并携带上之前B发回来的数据段作为序列号 seq 的值。

这样 3 次握手就完成了，主机 A 和主机 B 就可以传输数据了。

__简述四次挥手的过程：__

- 第一次：当主机 A 完成数据传输后，将控制位 FIN 置 1，提出停止 TCP 连接的请求；
- 第二次：主机 B 收到 FIN 后对其作出响应，然后将这一方向上的 TCP 消息接收通道将关闭，将 ACK 置为 1；
- 第三次：B 端最后的数据传输完成后，由 B 端再发出反方向的关闭请求，将 FIN 置 1；
- 第四次：主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束；

字段说明：

- ACK 是 TCP 报头的控制位之一，对数据进行确认。确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为 X，则表示前 X-1 个数据段都收到了，只有当 ACK=1 时, 确认号才有效，当 ACK=0 时，确认号无效，这时会要求重传数据，保证数据的完整性。
- SYN 同步序列号，TCP 建立连接时将这个位置 1。
- FIN 发送端完成发送任务位，当 TCP 完成数据传输需要断开时,，提出断开连接的一方将这位置 1。

__TCP 协议的包头结构__

![](https://nojsja.gitee.io/static-resources/images/interview/tcp-protocol.png)

源端口 16 位；目标端口 16 位；序列号 32 位；回应序号 32 位；TCP 头长度 4 位；reserved 保留 6 位；控制代码 6 位；窗口大小 16 位；偏移量 16 位；校验和 16 位；选项 32 位 (可选)；

这样我们得出了 TCP 包头的最小长度，为 20 字节。

#### 二、UDP 协议

UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

它有以下几个特点：

__面向无连接__

首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

__有单播，多播，广播的功能__

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

__UDP是面向报文的__

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

__不可靠性__

首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。

再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。



从上面的动态图可以得知，UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。

__头部开销小，传输数据报文时是很高效的__

![](https://nojsja.gitee.io/static-resources/images/interview/udp-protocol.jpg)

UDP 头部包含了以下几个数据：

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

#### 三、总结

|     | UDP | TCP |
| --- | --- | --- |
| 是否连接 | 无连接 | 面向连接 |
| 是否可靠 | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信 |
| 传输方式 | 面向报文 | 面向字节流 |
| 首部开销 | 首部开销小，仅8字节 | 首部最小20字节，最大60字节 |
| 适用场景 | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

## ➣ 浏览器缓存
### 1. 浏览器缓存的工作流程

&nbsp;&nbsp;&nbsp;&nbsp; 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

&nbsp;&nbsp;&nbsp;&nbsp; 这里先看张大家最熟悉的 Devtools 网络图：

![](http://nojsja.gitee.io/static-resources/images/http/network.png)

图中青色、绿色和橙色圈出的部分分别是来自内存 (memory 缓存)、磁盘 (disk 缓存) 和 Http 请求拿到的数据 (非缓存)，还有一种返回码 304 的请求也是从缓存 (memory/disk) 中获取数据。304 跟 memory/disk 缓存的区别是：在浏览器判断资源已经过期的情况下会去服务器查询资源是否更新，如果资源没更新则返回 304 码，浏览器收到 304 码就会更新资源的过期时间并直接从之前 disk/memory 缓存中拿到当前资源，换言之如果资源没过期，那么浏览器就会跳过向服务器校验资源这一步并直接去拿 memory/disk 缓存获取。

![](http://nojsja.gitee.io/static-resources/images/http/http_cache2.png)

大致流程如下：

- 1）首先检查是否存在 Service Worker Cache，没命中或不存在则进行下一步

- 2）检查内存中是否存在资源，存在的话直接加载 (from memory - 200)。

- 3）如果内存没有，择取从硬盘获取，存在且没过期的话直接加载 (from disk - 200)，过期了直接向服务器发送请求获取资源。如果资源没更新，服务器返回 304，浏览器从硬盘缓存中获取资源，并更新 ` 过期时间 / Etag/Last-Modified`。如果资源更新了则获取最新的资源，并通过 HTTP 请求将资源返回，重新缓存资源并更新 ` 过期时间 / Etag/Last-Modified`。

- 4）如果硬盘也没有，那么会向后端发送 HTTP 网络请求。

- 5）加载到的资源缓存到硬盘和内存，并更新资源的 ` 过期时间 / Etag/Last-Modified`。

&nbsp;&nbsp;&nbsp;&nbsp; `Service Worker Cache` 具有较高的优先级，数据控制更为复杂，操作自由度最高；`Memory Cache` 更多的强调了一种缓存存储方式和浏览器内存缓存策略；`HTTP Cache` 相对于 `Memory Cache` 根据存储方式的不同也能叫做 `Disk Cache`，它依赖于整个 HTTP 缓存校验流程 (强缓存和协商缓存)，并通过校验来最终确定何时从缓存读取，何时从服务器更新资源；Push Cache 资料较少，应用得不多，暂时只做介绍。

### 2. Service-Worker Cache(优先级最高)
---

&nbsp;&nbsp;&nbsp;&nbsp; Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

&nbsp;&nbsp;&nbsp;&nbsp; Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

&nbsp;&nbsp;&nbsp;&nbsp; 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

### 3. Memory Cache(优先级次之)

&nbsp;&nbsp;&nbsp;&nbsp; Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经获取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。内存缓存在缓存资源时并不关心返回资源的 HTTP 响应头部 Cache-Control 是什么值，换句话说这是一种强依赖于浏览器本地内存管理策略的缓存方式，各个浏览器对内存缓存的处理方式也略有区别。

&nbsp;&nbsp;&nbsp;&nbsp; Memory Cache 遵循这些策略：
- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

### 4. * HTTP Cache(优先级次之)

&nbsp;&nbsp;&nbsp;&nbsp; HTTP 缓存根据工作方式分为 ` 强缓存 ` 和 ` 协商缓存 `，浏览器首先会判断 ` 强缓存 ` 是否命中，命中失败才会尝试进行 ` 协商缓存 `。

![](http://nojsja.gitee.io/static-resources/images/http/http_cache.png)

1）强缓存

- \> HTTP 1.0 时代 - expires
&nbsp;&nbsp;&nbsp;&nbsp; 我们通过浏览器获取服务器远程资源时，服务器通过 http 请求 response headers 返回一个 `expires` 时间戳字段 (上图中蓝色部分)，例如 `expires: Wed, 13 Oct 2021 22:15:05 GMT`，表明这个资源的过期时间为格林威治时间 `2021 年 10 月 13 日 周三 22:15:05`(北京时间 + 8h = 格林威治时间)，浏览器判断当前时间在资源过期时间之前的话，就会从缓存中去读取资源 (如果缓存中存在的话)，否则会重新向服务器发送请求。
&nbsp;&nbsp;&nbsp;&nbsp; expires 的工作机制要求客户端时间与服务器时间误差较小，否则缓存更新策略可能在短时间不生效。

- \> HTTP 1.1 时代 - cache-control
&nbsp;&nbsp;&nbsp;&nbsp; `cache-control: max-age` 方式也是通过服务器返回资源时携带的 response headers 中的相应字段实现的，比如：`cache-control: max-age=31536000`，表明资源距浏览器接收到此资源后的 31536000 秒后过期。与 `expires` 返回的时间戳方式不同，cache-control 为了避免时间误差，直接返回一个时间长度，浏览器可以根据一个本地时间差值进行精确判断。
`cache-control` 其它相关字段还有：
&nbsp;&nbsp;&nbsp;&nbsp; __i.__ __public/private__：在依赖各种代理的大型架构中，我们不得不考虑代理服务器的缓存问题，public 与 private 用来控制代理服务缓存是否能缓存资源。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值，不过在只设置 s-maxage 的情况下，代理缓存也能生效。
&nbsp;&nbsp;&nbsp;&nbsp; __ii.__ __s-maxage__：针对于代理服务器的缓存问题，此字段用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，只对 public 缓存有效，`cache-control: max-age=3600, s-maxage=31536000`。
&nbsp;&nbsp;&nbsp;&nbsp; __iii.__ __no-cache__：为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期，直接进行 ` 协商缓存 `。
&nbsp;&nbsp;&nbsp;&nbsp; __iv.__ __no-store__：不使用任何缓存策略，每次请求都直接从服务器获取，并在浏览器客户端不进行资源缓存。

- \> cache-control 和 expires 并存
&nbsp;&nbsp;&nbsp;&nbsp; cache-control 的优先级更高，当 cache-control 与 expires 同时出现时，以 cache-control 为准，不过考虑向下兼容性可以选择同时使用两种缓存策略。

2）协商缓存

&nbsp;&nbsp;&nbsp;&nbsp; 协商缓存依赖于服务端与浏览器之间的通信，在第一次获取资源时浏览器会存储 HTTP 请求的 response headers 字段：Last-Modified / Etag，当强缓存未命中的时候，它的值作为浏览器和服务器通信时携带的标志位用于判断资源是否过期，如果服务器判断资源过期的话就会重新下载资源，并更新相应标志位。如果判断资源未更新的话，会返回 304 状态码，浏览器就会复用客户端缓存资源。

- \> Last-Modified 和 If-Modified-Since 方式
&nbsp;&nbsp;&nbsp;&nbsp; `Last-Modified` 为随服务器端 HTTP 响应头部返回的时间戳标志，表示一个资源最近一次被更新的时间，客户端请求资源时添加上 request headers 字段 `If-Modified-Since`(值与 Last-Modified 相同) 用于服务器做校验判断资源是否更新，`Last-Modified: Wed, 13 Jan 2021 15:34:55 GMT`。
使用 Last-Modified 存在一些弊端：
&nbsp;&nbsp;&nbsp;&nbsp; __i. 命中失误 1：__ 当我们更新了服务器的某个资源文件，但其实际内容并未发生变化，其相应的资源更新时间戳会改变，浏览器端在服务端文件并未发生改变的情况下，仅仅通过时间戳这种判断方式也会导致资源被完全重新下载。
&nbsp;&nbsp;&nbsp;&nbsp; __ii. 命中失误 2：__ If-Modified-Since 只能检查到以秒为最小计量单位的时间差，感知不到 1s 以内的文件改动的情况，这会导致一些浏览器缓存更新不及时的情况。

- \> Etag 和 If-None-Match 方式
&nbsp;&nbsp;&nbsp;&nbsp; `Etag` 就是为了弥补 `Last-Modified` 的弊端而产生的新的协商缓存方式。Etag 为随服务器端 HTTP 请求头部返回的资源唯一标志，例如：`ETag: W/"2a3b-1602480f459"`，它根据资源内容而生成，可以精确感知资源的变动情况，即使多次更新，只要内容不变，Etag 值也是不会变化的。浏览器下一次请求此资源时，request headers 里就会带上一个值相同的名为 `if-None-Match` 的字段用于服务器对此资源做对比，`If-None-Match: W/"2a3b-1602480f459"`。

- \> `Etag` 在感知文件变化上比 `Last-Modified` 更加准确，优先级也更高，不过 `Etag` 的生成会消耗掉部分服务器的性能，它可以作为一种辅助协商缓存方式与前者相互配合使用。当 `Etag` 和 `Last-Modified` 同时存在时，以 `Etag` 为准。

### 5. Push Cache(优先级最低)

Push Cache 是指 HTTP2 在 server push 阶段存在的缓存：

- Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。

## ➣ Cookie 缓存

Web Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。

### 一、创建 Cookie

当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 `Set-Cookie` 选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

```console
Set-Cookie: <cookie 名>=<cookie 值 >
```

### 二、Cookie 生命周期

- __会话期 Cookie__：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。
- __持久性 Cookie__：生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

```console
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 三、Cookie 安全性

有两种方法可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问：Secure 属性和 HttpOnly 属性：

- 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端，因此可以预防中间者攻击。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。

- Js `document.cookie` API 无法访问带有 HttpOnly 属性的 cookie。此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。

- SameSite Cookie：Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。SameSite 有三个值：
  ```console
  Set-Cookie: key=value; SameSite=Strict
  ```
  - __None__：浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。
  - __Strict__：浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）
  - __Lax__：与 Strict 类似，但用户从外部站点导航至 URL 时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到 URL 时才会发送，如 link 链接。
