---
lang: zh-CN
title: ● 基础知识
description: Network & System 的描述
---

### > cpu 调度算法
--------------------------------------------
### > cookie 中常见的字段
--------------------------------------------

### > 什么是堆？什么是栈？它们之间有什么区别和联系？
--------------------------------------------

数据结构中堆是满足父子节点大小（比如大根堆中规定父节点的值要比子节点大）关系的一种完全二叉树。由于是完全二叉树，可以用数组来实现，用节点编号来访问和操作节点，简化程序，提升效率。而其大小关系则为我们查询堆中极值提供了常数级别的时间复杂度，又由二叉树的性质，插入和删除则为对数级别时间复杂度。这就好像地位不同的人在排队，排在最前面的一定是地位最高的人，所以堆是优先队列（Priority Queue）实现的基础。利用这一特性，可以加速某些需要频繁取队列中极值的算法比如 A* 算法等。

数据结构中的栈则是一种相当简单的结构。就像是只有一个口的深深的文件桶，先进去的文件会被压在下面（push），而且我们每次只能取到最上面的文件（pop），体现了其先进后出（FILO）的特性。虽然栈操作简单，但也有如单调栈等在栈内保持一定数据特性的变种。

操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。__内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存__，即使是同一个程序也可能占用了不同地方的多块内存。操作系统中则会对这些空间进行统一的管理，在应用程序提出申请时，就会从堆中按照一定算法找出一块可用内存，标记占用空间等信息之后返回其起始地址给程序。在程序结束之前，操作系统不会删除已经申请的内存，而是要靠程序主动提出释放的请求（free、delete），如果使用后忘记释放，就会造成所谓的内存泄漏问题。因此堆基本上可以理解为当前可以使用的空闲内存，但是其申请和释放都要程序员自己写代码管理。

而操作系统的栈则是程序运行时自动拥有的一小块内存，大小在编译期时由编译器参数决定，用于局部变量的存放或者函数调用栈的保存。在 C 中如果声明一个局部变量（例如 int a），它存放的地方就在栈中，而当这个局部变量离开其作用域之后，所占用的内存则会被自动释放，因此在 C 中局部变量也叫自动变量。栈的另一个作用则是保存函数调用栈，这时和数据结构的栈就有关系了。在函数调用过程中，常常会多层甚至递归调用。每一个函数调用都有各自的局部变量值和返回值，每一次函数调用其实是先将当前函数的状态压栈，然后在栈顶开辟新空间用于保存新的函数状态，接下来才是函数执行。当函数执行完毕之后，栈先进后出的特性使得后调用的函数先返回，这样可以保证返回值的有序传递，也保证函数现场可以按顺序恢复。操作系统的栈在内存中高地址向低地址增长，也即低地址为栈顶，高地址为栈底。这就导致了栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把你的程序杀掉。

### > TCP 和 UDP 协议的区别
-------------------------

#### 一、TCP 协议

TCP 协议隶属于 TCP/IP 协议簇中的一个重要协议，它位于传输层。

TCP 协议是面向连接的，是一种可靠的传输协议。客户端和服务端开始通信之前需要通过三次握手保证连接正常建立，并确定连接双方都可正常收发消息。

__简述三次握手的过程：__

> SYN 这个标志位只有在 TCP 建立连接时才会被置 1 , 握手完成后 SYN 标志位被置 0。

- i. 第一次握手：主机 A 通过向主机 B 发送一个含有同步序列号的标志位的数据段给主机 B，向主机 B 请求建立连接，通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。
- ii. 第二次握手：主机 B 收到主机 A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我
- iii. 第三次握手：主机 A 收到这个数据段后，再发送一个确认应答，确认已收到主机 B 的数据段：" 我已收到回复，我现在要开始传输实际数据了，这样 3 次握手就完成了，主机 A 和主机 B 就可以传输数据了。

__简述四次挥手的过程：__

- i. 第一次：当主机 A 完成数据传输后，将控制位 FIN 置 1，提出停止 TCP 连接的请求；
- ii. 第二次：主机 B 收到 FIN 后对其作出响应，然后将这一方向上的 TCP 消息接收通道将关闭，将 ACK 置为 1；
- iii. 第三次：B 端最后的数据传输完成后，由 B 端再发出反方向的关闭请求，将 FIN 置 1；
- iv. 第四次：主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束；

字段说明：

- ACK 是 TCP 报头的控制位之一，对数据进行确认。确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为 X，则表示前 X-1 个数据段都收到了，只有当 ACK=1 时, 确认号才有效，当 ACK=0 时，确认号无效，这时会要求重传数据，保证数据的完整性。
- SYN 同步序列号，TCP 建立连接时将这个位置 1。
- FIN 发送端完成发送任务位，当 TCP 完成数据传输需要断开时,，提出断开连接的一方将这位置 1。

__TCP 协议的包头结构__

![](https://nojsja.gitee.io/static-resources/images/interview/tcp-protocol.png)

源端口 16 位；目标端口 16 位；序列号 32 位；回应序号 32 位；TCP 头长度 4 位；reserved保留 6 位；控制代码 6 位；窗口大小 16 位；偏移量 16 位；校验和 16 位；选项 32 位 (可选)；

这样我们得出了 TCP 包头的最小长度，为 20 字节。

#### 二、UDP 协议


UDP 协议 (用户数据报协议) 是面向报文的，是一种非可靠协议，位于传输层，传输数据之前源端和终端不建立连接。

它适用于一些低精度的通信场景，比如网络直播，丢失了一两帧的数据，但是数据通信的性能得到了提升。

UDP 信息包头很短，只有 8 个字节。UDP 传送数据的速度仅仅是受应用程序生成数据的速度、计算机的性能和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文， 在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

__UDP 的包头结构：__

![](https://nojsja.gitee.io/static-resources/images/interview/udp-protocol.jpg)

源端口 16 位；目的端口 16 位；UDP 长度 16 位；校验和 16 位

#### 三、总结

1. 基于连接与无连接；
2. 对系统资源的要求（TCP 较多，UDP 少）；
3. UDP 程序结构较简单；
4. 流模式与数据报模式；
5. TCP 保证数据正确性，UDP 可能丢包；
6. TCP 保证数据顺序，UDP 不保证；