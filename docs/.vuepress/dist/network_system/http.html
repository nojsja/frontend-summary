<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <title>● HTTP 协议 | NoJsJa Frontend Summary</title><meta name="description" content="网络协议">
    <link rel="modulepreload" href="/frontend-summary/assets/app.6a7323b4.js"><link rel="modulepreload" href="/frontend-summary/assets/http.html.f182ae29.js"><link rel="modulepreload" href="/frontend-summary/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/frontend-summary/assets/http.html.82287b48.js">
    <link rel="stylesheet" href="/frontend-summary/assets/style.c7eaaf18.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/frontend-summary/" class=""><img class="logo" src="https://nojsja.gitee.io/blogs/img/avatar/nojsja.jpeg" alt="NoJsJa Frontend Summary"><span class="site-name can-hide">NoJsJa Frontend Summary</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://nojsja.gitee.io/blogs" rel="noopener noreferrer" target="_blank" aria-label="Blogs"><!--[--><!--]--> Blogs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/nojsja" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://nojsja.gitee.io/blogs" rel="noopener noreferrer" target="_blank" aria-label="Blogs"><!--[--><!--]--> Blogs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/nojsja" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/frontend-summary/" class="sidebar-item sidebar-heading" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/html_css" class="sidebar-item sidebar-heading" aria-label="➣ HTML/CSS 部分"><!--[--><!--]--> ➣ HTML/CSS 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/html_css/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/html_css/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/js" class="sidebar-item sidebar-heading" aria-label="➣ Javascript 部分"><!--[--><!--]--> ➣ Javascript 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/js/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/js/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/react" class="sidebar-item sidebar-heading" aria-label="➣ React 部分"><!--[--><!--]--> ➣ React 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/react/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/react/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/node" class="sidebar-item sidebar-heading" aria-label="➣ Node 部分"><!--[--><!--]--> ➣ Node 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/node/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/node/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/optimization" class="sidebar-item sidebar-heading" aria-label="➣ 前端性能优化"><!--[--><!--]--> ➣ 前端性能优化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/optimization/code.html" class="sidebar-item" aria-label="● 编码优化"><!--[--><!--]--> ● 编码优化 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/optimization/http.html" class="sidebar-item" aria-label="● http 优化"><!--[--><!--]--> ● http 优化 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/optimization/build.html" class="sidebar-item" aria-label="● 构建优化"><!--[--><!--]--> ● 构建优化 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/structure" class="sidebar-item sidebar-heading" aria-label="➣ 前端工程化和架构"><!--[--><!--]--> ➣ 前端工程化和架构 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/structure/arch.html" class="sidebar-item" aria-label="● 架构"><!--[--><!--]--> ● 架构 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/structure/engineered.html" class="sidebar-item" aria-label="● 工程化"><!--[--><!--]--> ● 工程化 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/structure/project.html" class="sidebar-item" aria-label="● 前项目梳理"><!--[--><!--]--> ● 前项目梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/network_system" class="router-link-active sidebar-item sidebar-heading active" aria-label="➣ 操作系统和网络"><!--[--><!--]--> ➣ 操作系统和网络 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/network_system/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/network_system/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="● HTTP 协议"><!--[--><!--]--> ● HTTP 协议 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-http-的特点和缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTP 的特点和缺点"><!--[--><!--]--> ➣ HTTP 的特点和缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-http-报文组成部分" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTP 报文组成部分"><!--[--><!--]--> ➣ HTTP 报文组成部分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-http-请求方法-9种" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTP 请求方法(9种)"><!--[--><!--]--> ➣ HTTP 请求方法(9种) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-get-和-post-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ GET 和 POST 的区别"><!--[--><!--]--> ➣ GET 和 POST 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-常见-http-状态码" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 常见 HTTP 状态码"><!--[--><!--]--> ➣ 常见 HTTP 状态码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-关于长连接、短连接、长轮询" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 关于长连接、短连接、长轮询"><!--[--><!--]--> ➣ 关于长连接、短连接、长轮询 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-什么是管线化-管道化" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 什么是管线化(管道化)"><!--[--><!--]--> ➣ 什么是管线化(管道化) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-如何解决-http-的队头阻塞问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 如何解决 HTTP 的队头阻塞问题"><!--[--><!--]--> ➣ 如何解决 HTTP 的队头阻塞问题 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-https" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTPS"><!--[--><!--]--> ➣ HTTPS <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend-summary/network_system/http.html#ssl-tls" class="router-link-active router-link-exact-active sidebar-item" aria-label="SSL/TLS"><!--[--><!--]--> SSL/TLS <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#会话复用" class="router-link-active router-link-exact-active sidebar-item" aria-label="会话复用"><!--[--><!--]--> 会话复用 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-http-的发展" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTP 的发展"><!--[--><!--]--> ➣ HTTP 的发展 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-https优缺点" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTPS优缺点"><!--[--><!--]--> ➣ HTTPS优缺点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/http.html#➣-http-和-https-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ HTTP 和 HTTPS 的区别"><!--[--><!--]--> ➣ HTTP 和 HTTPS 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/network_system/https.html" class="sidebar-item" aria-label="● HTTPS 协议"><!--[--><!--]--> ● HTTPS 协议 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/network_system/http2.0.html" class="sidebar-item" aria-label="● HTTP 2.0"><!--[--><!--]--> ● HTTP 2.0 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/design_pattern" class="sidebar-item sidebar-heading" aria-label="➣ 设计模式"><!--[--><!--]--> ➣ 设计模式 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/design_pattern/decorator.html" class="sidebar-item" aria-label="● 装饰器模式"><!--[--><!--]--> ● 装饰器模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/flyweight.html" class="sidebar-item" aria-label="● 享元模式"><!--[--><!--]--> ● 享元模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/observer.html" class="sidebar-item" aria-label="● 观察者模式"><!--[--><!--]--> ● 观察者模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/proxy.html" class="sidebar-item" aria-label="● 代理模式"><!--[--><!--]--> ● 代理模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/responsibility_chain.html" class="sidebar-item" aria-label="● 责任链模式"><!--[--><!--]--> ● 责任链模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/state.html" class="sidebar-item" aria-label="● 状态模式"><!--[--><!--]--> ● 状态模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/strategy.html" class="sidebar-item" aria-label="● 策略模式"><!--[--><!--]--> ● 策略模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/template.html" class="sidebar-item" aria-label="● 模板方法模式"><!--[--><!--]--> ● 模板方法模式 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/data" class="sidebar-item sidebar-heading" aria-label="➣ 数据结构"><!--[--><!--]--> ➣ 数据结构 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/data/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/data/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/algorithms" class="sidebar-item sidebar-heading" aria-label="➣ 算法"><!--[--><!--]--> ➣ 算法 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/algorithms/array.html" class="sidebar-item" aria-label="● 数组"><!--[--><!--]--> ● 数组 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/dp.html" class="sidebar-item" aria-label="● 动态规划"><!--[--><!--]--> ● 动态规划 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/linked_list.html" class="sidebar-item" aria-label="● 链表"><!--[--><!--]--> ● 链表 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/string.html" class="sidebar-item" aria-label="● 字符串处理"><!--[--><!--]--> ● 字符串处理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/sort.html" class="sidebar-item" aria-label="● 排序算法"><!--[--><!--]--> ● 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/tree.html" class="sidebar-item" aria-label="● 树"><!--[--><!--]--> ● 树 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/others.html" class="sidebar-item" aria-label="● 其它"><!--[--><!--]--> ● 其它 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="➣-http-的特点和缺点" tabindex="-1"><a class="header-anchor" href="#➣-http-的特点和缺点" aria-hidden="true">#</a> ➣ HTTP 的特点和缺点</h2><p><strong>特点</strong>：<code>无连接</code>、<code>无状态</code>、<code>灵活</code>、<code>简单快速</code></p><ul><li><strong>无连接</strong>：每一次请求都要连接一次，请求结束就会断掉，不会保持连接</li><li><strong>无状态</strong>：每一次请求都是独立的，请求结束不会记录连接的任何信息(<strong>提起裤子就不认人的意思</strong>)，减少了网络开销，这<code>是优点也是缺点</code></li><li><strong>灵活</strong>：通过http协议中头部的<code>Content-Type</code>标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活</li><li><strong>简单快速</strong>：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快</li></ul><p><strong>缺点</strong>：<code>无状态</code>、<code>不安全</code>、<code>明文传输</code>、<code>队头阻塞</code></p><ul><li><strong>无状态</strong>：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li><li><strong>不安全</strong>：<code>明文传输</code>可能被窃听不安全，缺少<code>身份认证</code>也可能遭遇伪装，还有缺少<code>报文完整性验证</code>可能遭到篡改</li><li><strong>明文传输</strong>：报文(header部分)使用的是明文，直接将信息暴露给了外界，<code>WIFI陷阱</code>就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息</li><li><strong>队头阻塞</strong>：开启<code>长连接</code>(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)</li></ul><h2 id="➣-http-报文组成部分" tabindex="-1"><a class="header-anchor" href="#➣-http-报文组成部分" aria-hidden="true">#</a> ➣ HTTP 报文组成部分</h2><p><strong>http报文</strong>：由<code>请求报文</code>和<code>响应报文</code>组成</p><p><strong>请求报文</strong>：由<code>请求行</code>、<code>请求头</code>、<code>空行</code>、<code>请求体</code>四部分组成</p><p><strong>响应报文</strong>：由<code>状态行</code>、<code>响应头</code>、<code>空行</code>、<code>响应体</code>四部分组成</p><ul><li><strong>请求行</strong>：包含http方法，请求地址，http协议以及版本</li><li><strong>请求头/响应头</strong>：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等，<a href="https://link.juejin.cn?target=https%3A%2F%2Fkb.cnblogs.com%2Fpage%2F92320%2F" title="https://kb.cnblogs.com/page/92320/" target="_blank" rel="noopener noreferrer">请求头/响应头每一个字段详解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></li><li><strong>空行</strong>：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了</li><li><strong>请求体</strong>：请求的参数</li><li><strong>状态行</strong>：包含http协议及版本、数字状态码、状态码英文名称</li><li><strong>响应体</strong>：服务端返回的数据</li></ul><h2 id="➣-http-请求方法-9种" tabindex="-1"><a class="header-anchor" href="#➣-http-请求方法-9种" aria-hidden="true">#</a> ➣ HTTP 请求方法(9种)</h2><p><strong>HTTP1.0：</strong> <code>GET</code>、<code>POST</code>、<code>HEAD</code></p><p><strong>HTTP1.1：</strong> <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输资源，通常会造成服务器资源的修改</td></tr><tr><td>HEAD</td><td>获得报文首部</td></tr><tr><td>PUT</td><td>更新资源</td></tr><tr><td>PATCH</td><td>对PUT的补充，对已知资源部分更新 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fhttp%2Fhttp-methods.html" title="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener noreferrer">菜鸟<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></td></tr><tr><td>DELETE</td><td>删除资源</td></tr><tr><td>OPTIONS</td><td>列出请求资源支持的请求方法，用来跨域请求</td></tr><tr><td>TRACE</td><td>追踪请求/响应路径，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>将连接改为管道方式用于代理服务器(<code>隧道代理</code>下面有讲)</td></tr></tbody></table><h2 id="➣-get-和-post-的区别" tabindex="-1"><a class="header-anchor" href="#➣-get-和-post-的区别" aria-hidden="true">#</a> ➣ GET 和 POST 的区别</h2><ul><li><code>GET</code>在浏览器回退时是无害的，而<code>POST</code>会再次发起请求</li><li><code>GET</code>请求会被浏览器主动缓存，而<code>POST</code>不会，除非手动设置</li><li><code>GET</code>请求参数会被安逗保留在浏览器历史记录里，而<code>POST</code>中的参数不会被保留</li><li><code>GET</code>请求在<code>URL</code>中传递的参数有长度限制(浏览器限制大小不同)，而<code>POST</code>没有限制</li><li><code>GET</code>参数通过<code>URL</code>传递，<code>POST</code>放在<code>Request body</code>中</li><li><code>GET</code>产生的URL地址可以被收藏，而<code>POST</code>不可以</li><li><code>GET</code>没有<code>POST</code>安全，因为<code>GET</code>请求参数直接暴露在<code>URL</code>上，所以不能用来传递敏感信息</li><li><code>GET</code>请求只能进行<code>URL</code>编码，而<code>POST</code>支持多种编码方式</li><li>对参数的数据类型，<code>GET</code>只接受<code>ASCII</code>字符，而<code>POST</code>没有限制</li><li><code>GET</code>产生一个TCP数据包，<code>POST</code>产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200</li></ul><h2 id="➣-常见-http-状态码" tabindex="-1"><a class="header-anchor" href="#➣-常见-http-状态码" aria-hidden="true">#</a> ➣ 常见 HTTP 状态码</h2><p><strong>1xx: 指示信息——表示请求已接收，继续处理</strong></p><p><strong>2xx: 成功——表示请求已被成功接收</strong></p><p><strong>3xx: 重定向——表示要完成请求必须进行进一步操作</strong></p><p><strong>4xx: 客户端错误——表示请求有语法错误或请求无法实现</strong></p><p><strong>5xx: 服务端错误——表示服务器未能实现合法的请求</strong></p><p>常见状态码：</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>请求成功</td></tr><tr><td>206</td><td>已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时</td></tr><tr><td>301</td><td>永久重定向</td></tr><tr><td>302</td><td>临时重定向</td></tr><tr><td>304</td><td>请求资源未修改，可以使用缓存的资源，不用在服务器取</td></tr><tr><td>400</td><td>请求有语法错误</td></tr><tr><td>401</td><td>没有权限访问</td></tr><tr><td>403</td><td>服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时</td></tr><tr><td>404</td><td>请求资源不存在</td></tr><tr><td>500</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>503</td><td>请求未完成，因服务器过载、宕机或维护等</td></tr></tbody></table><h2 id="➣-关于长连接、短连接、长轮询" tabindex="-1"><a class="header-anchor" href="#➣-关于长连接、短连接、长轮询" aria-hidden="true">#</a> ➣ 关于长连接、短连接、长轮询</h2><h4 id="_1-http-长连接-短连接" tabindex="-1"><a class="header-anchor" href="#_1-http-长连接-短连接" aria-hidden="true">#</a> 1. HTTP 长连接 / 短连接</h4><p>在 HTTP/1.0 中默认使用 http 短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p><p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性，提高传输的效率和减低服务器的开销。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>Connection:keep-alive
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p><h4 id="_2-http-长轮询" tabindex="-1"><a class="header-anchor" href="#_2-http-长轮询" aria-hidden="true">#</a> 2. HTTP 长轮询</h4><p>HTTP 长轮询是人为编程实现的一种通信方式，它在短轮询的基础上加入服务端的连接保持、连接超时和数据变化监听等功能。而 HTTP 长连接本质上是 http 协议的特性，主要用于优化客户端的连接重用，减少资源占用，不可人为编程。</p><h4 id="_3-长连接优缺点" tabindex="-1"><a class="header-anchor" href="#_3-长连接优缺点" aria-hidden="true">#</a> 3. 长连接优缺点</h4><p>优点：</p><ul><li><code>减少CPU及内存的使用</code>，因为不需要经常建立和关闭连接；</li><li><code>支持管道化</code>的请求及响应模式；</li><li><code>减少网络堵塞</code>，因为减少了TCP请求；</li><li><code>减少了后续请求的响应时间</code>，因为不需要等待建立TCP、握手、挥手、关闭TCP的过程；</li><li>发生错误时，也<code>可在不关闭连接的情况下进行错误提示</code>；</li></ul><p>缺点：</p><p>一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数</p><p>还有就是可能造成<code>队头堵塞</code>(下面有讲)，造成信息延迟。</p><h4 id="_4-如何避免长连接资源浪费" tabindex="-1"><a class="header-anchor" href="#_4-如何避免长连接资源浪费" aria-hidden="true">#</a> 4. 如何避免长连接资源浪费？</h4><ul><li><strong>客户端请求头声明</strong>：<code>Connection: close</code>，本次通信后就关闭连接；</li><li><strong>服务端配置</strong>：如Nginx，设置<code>keepalive_timeout</code>设置长连接超时时间，<code>keepalive_requests</code>设置长连接请求次数上限；</li><li><strong>系统内核参数设置</strong>： <ul><li><code>net.ipv4.tcp_keepalive_time = 60</code>，连接闲置60秒后，服务端尝试向客户端发送侦测包，判断TCP连接状态，如果没有收到ack反馈就在</li><li><code>net.ipv4.tcp_keepalive_intvl = 10</code>，就在10秒后再次尝试发送侦测包，直到收到ack反馈，一共会</li><li><code>net.ipv4.tcp_keepalive_probes = 5</code>，一共会尝试5次，要是都没有收到就关闭这个TCP连接了</li></ul></li></ul><h2 id="➣-什么是管线化-管道化" tabindex="-1"><a class="header-anchor" href="#➣-什么是管线化-管道化" aria-hidden="true">#</a> ➣ 什么是管线化(管道化)</h2><p><code>http1.1</code>在使用<code>长连接</code>的情况下，建立一个连接通道后，连接上消息的传递类似于</p><blockquote><p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</p></blockquote><p><code>管理化</code>连接的消息就变成了类似这样</p><blockquote><p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p></blockquote><p><code>管线化</code>是在同一个TCP连接里<strong>发一个请求后不必等其回来就可以继续发请求出去</strong>，这可以减少整体的响应时间，但是服务器还是<strong>会按照请求的顺序响应</strong>请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题<code>队头堵塞</code>(下面有讲解决方法)</p><p>管线化的特点：</p><ul><li>管线化机制通过持久连接完成，在<code>http1.1</code>版本才支持；</li><li>只有<code>GET</code>请求和<code>HEAD</code>请求才可以进行管线化，而<code>POST</code>有所限制；</li><li>初次创建连接时不应启动管线化机制，因为服务器不一定支持http1.1版本的协议；</li><li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序就是请求的顺序；</li><li>要求<code>客户端</code>和<code>服务端</code>都支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可；</li><li>由于上面提到的服务端问题，开户管线化很可能并不会带来大幅度的性能提升，而且很多服务端和代理程序对管线化的支持并不好，因为浏览器(Chrome/Firefox)默认并未开启管线化支持；</li></ul><h2 id="➣-如何解决-http-的队头阻塞问题" tabindex="-1"><a class="header-anchor" href="#➣-如何解决-http-的队头阻塞问题" aria-hidden="true">#</a> ➣ 如何解决 HTTP 的队头阻塞问题</h2><p><code>http1.0</code>协议采用的是<code>请求-应答</code>模式，报文必须是<code>一发一收</code>，就形成了一个<code>先进先出</code>的串行队列，没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求最先处理，就导致如果队首的请求耗时过长，后面的请求就只能处于阻塞状态，这就是著名的<code>队头阻塞</code>问题。解决如下：</p><h4 id="并发连接" tabindex="-1"><a class="header-anchor" href="#并发连接" aria-hidden="true">#</a> 并发连接</h4><p>因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。以前在RFC2616中规定过客户端最多只能并发2个连接，但是现实是很多浏览器不按套路出牌，就是遵守这个标准T_T，所以在RFC7230把这个规定取消掉了，现在的浏览器标准中一个域名<code>并发连接</code>可以有<code>6~8</code>个，记住是6~8个，不是6个(<strong>Chrome6个/Firefox8个</strong>)。</p><h4 id="域名分片" tabindex="-1"><a class="header-anchor" href="#域名分片" aria-hidden="true">#</a> 域名分片</h4><p>一个域名最多可以并发6~8个，比如a.baidu.com，b.baidu.com，c.baidu.com，多准备几个<code>二级域名</code>，当我们访问baidu.com时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了。</p><p>而在<code>HTTP2.0</code>下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个TCP连接中发送多个请求。</p><h2 id="➣-https" tabindex="-1"><a class="header-anchor" href="#➣-https" aria-hidden="true">#</a> ➣ HTTPS</h2><p><code>HTTPS</code> 是超文本传输安全协议，即<code>HTTP + SSL/TLS</code>。说白了，就是一个加强版的HTTP</p><p><img src="https://nojsja.gitee.io/static-resources/images/interview/http-ssl.png" alt=""></p><p>HTTP本文开始讲了，所以我们要理解HTTPS的精华，就要先弄清楚这个<code>SSL/TLS</code>了</p><h3 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h3><p>TLS是SSL的升级版，而且TLS1.2版本以下都已废弃，目前主要用的是<code>TLS 1.2</code>和<code>TLS 1.3</code>。而<strong>OpenSSL</strong>则是<strong>开源版本</strong>的</p><p>那么它到底是个啥呢？</p><p>浏览器和服务器通信之前会先协商，选出它们都支持的<code>加密套件</code>，用来实现安全的通信。<a href="https://link.juejin.cn?target=https%3A%2F%2Fciphersuite.info%2Fcs%2F%3Fsoftware%3Dopenssl%26singlepage%3Dtrue" title="https://ciphersuite.info/cs/?software=openssl&amp;singlepage=true" target="_blank" rel="noopener noreferrer">常见加密套件<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><p>随便拿出一个加密套件举例，如：<strong>RSA-PSK-AES128-GCM-SHA256</strong>，就是长这样，代表什么意思呢，我们看图</p><p><img src="https://nojsja.gitee.io/static-resources/images/interview/http-suit.png" alt=""></p><ul><li><strong><code>RSA</code></strong>：表示握手时用RSA算法交换密钥</li><li><strong><code>PSK</code></strong>：表示使用PSK算法签名</li><li><strong><code>AES128-GCM</code></strong>：表示使用AES256对称加密算法通信，密钥长度128，分组模式GCM。TLS 1.3中只剩下称加密算法有<strong>AES</strong>和<strong>CHACHA20</strong>，分组模式只剩下<strong>GCM</strong>和<strong>POLY1305</strong></li><li><strong><code>SHA256</code></strong>：表示使用SHA256算法验证信息完整性并生成随机数。TLS 1.3中哈希摘要算法只剩下<strong>SHA256</strong>和<strong>SHA384</strong>了</li></ul><p>为什么需要用到这么多算法呢？</p><p>为了保证安全，TLS需要保证信息的：<code>机密性</code>、<code>可用性</code>、<code>完整性</code>、<code>认证性</code>、<code>不可否认性</code>，每一种算法都有其特定的用处 简单说就是简化了握手过程，只有三步，把原来的两个RTT打包成一个发送了，所以减少了传输次数。这种握手方式也叫<code>1-RTT</code>握手 ​ 这种握手方还有优化空间吗？ ​ 有的，用会话复用 ​</p><h3 id="会话复用" tabindex="-1"><a class="header-anchor" href="#会话复用" aria-hidden="true">#</a> 会话复用</h3><p>​ 会话复用有两种方式：<code>Session ID</code> 和 <code>Session Ticket</code> ​ <strong><code>Session ID</code></strong>：就是客户端和服务器首次连接手各自保存会话ID，并存储会话密钥，下次再连接时，客户端发送ID过来，服务器这边再查找ID，如果找到了就直接复用会话，密钥也不用重新生成。</p><p>可是这样的话，在客户端数量庞大的时候，对服务器的存储压力可就大了，所以出来了第二种方式 <strong><code>Session Ticket</code></strong>：就是双方连接成功后服务器加密会话信息，用Session Ticket消息发给客户端存储起来，下次再连接时就把这个Session Ticket解密，验证有没有过期，如果没有过期就复用会话。原理就是把存储压力分给客户端。</p><p>这样也存在安全问题，因为每次要用一个固定的密钥来解密Session Ticket，一旦密钥被窃取，那所有历史记录也就被破解了，所以只能尽量避免这种问题<code>定期更换密钥</code>。毕竟节省了不少生成会话密钥和这些算法的耗时，性能还是提升了嘛。</p><p>那刚说了<code>1-RTT</code>，那能不能优化到<code>0-RTT</code>呢 ​ 还真可以，做法就是发送Session Ticket的时候带上应用数据，不用等服务端确认。这种方式被称为<code>PSK</code>(Pre-Shared Key)​</p><p>这样万无一失了吗？ ​ 尴了个尬，还是不行。这PSK要是被窃取，人家不断向服务器重发，就直接增加了服务器被攻击的风险 ​ 虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本 ​</p><h2 id="➣-http-的发展" tabindex="-1"><a class="header-anchor" href="#➣-http-的发展" aria-hidden="true">#</a> ➣ HTTP 的发展</h2><p>1991年HTTP 0.9版，只有一个GET，而且只支持纯文本内容，早已过时就不讲了</p><h4 id="http-1-0-1996年" tabindex="-1"><a class="header-anchor" href="#http-1-0-1996年" aria-hidden="true">#</a> HTTP 1.0(1996年)</h4><ul><li>任意数据类型都可以发送</li><li>有GET、POST、HEAD三种方法</li><li>无法复用TCP连接(长连接)</li><li>有丰富的请求响应头信息。以header中的<code>Last-Modified</code>/<code>If-Modified-Since</code>和<code>Expires</code>作为缓存标识</li></ul><h4 id="http-1-1-1997年" tabindex="-1"><a class="header-anchor" href="#http-1-1-1997年" aria-hidden="true">#</a> HTTP 1.1(1997年)</h4><ul><li>引入更多的请求方法类型<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></li><li>引入长连接，就是TCP连接默认不关闭，可以被多个请求复用，通过请求头connection:keep-alive设置</li><li>引入管道连接机制，可以在同一TCP连接里，<code>同时发送</code>多个请求</li><li>强化了缓存管理和控制<code>Cache-Control</code>、<code>ETag</code>/<code>If-None-Match</code></li><li>支持分块响应，断点续传，利于大文件传输，能过请求头中的<code>Range</code>实现</li><li>使用了<code>虚拟网络</code>，在一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址</li></ul><p><strong>缺点</strong>：主要是连接缓慢，服务器只能按顺序响应，如果某个请求花了很长时间，就会出现请求队头阻塞</p><p>虽然出了很多优化技巧：为了增加并发请求，做域名拆分、资源合并、精灵图、资源预取...等等</p><p>最终为了推进从协议上进行优化，Google跳出来，推出<code>SPDY</code>协议</p><h4 id="spdy-2009年" tabindex="-1"><a class="header-anchor" href="#spdy-2009年" aria-hidden="true">#</a> SPDY(2009年)</h4><p>SPDY（读作“SPeeDY”）是Google开发的基于TCP的<code>会话层协议</code></p><p>主要通过帧、多路复用、请求优先级、HTTP报头压缩、服务器推送以最小化网络延迟，提升网络速度，优化用户的网络使用体验</p><p>原理是在SSL层上增加一个SPDY会话层，以在一个TCP连接中实现并发流。通常的HTTP GET和POST格式仍然是一样的，然而SPDY为编码和传输数据设计了一个新的帧格式。因为流是双向的，所以可以在客户端和服务端启动</p><p>虽然诞生后很快被所有主流浏览器所采用，并且服务器和代理也提供了支持，但是SPDY核心人员后来都参加到HTTP 2.0开发中去了，自HTTP2.0开发完成就不再支持SPDY协议了，并在Chrome 51中删掉了SPDY的支持</p><h4 id="http-2-0-2015年" tabindex="-1"><a class="header-anchor" href="#http-2-0-2015年" aria-hidden="true">#</a> HTTP 2.0(2015年)</h4><p>说出http2中至少三个新特性？</p><ul><li>使用新的<code>二进制协议</code>，不再是纯文本，避免文本歧义，缩小了请求体积</li><li><code>多路复用</code>，同域名下所有通信都是在单链接(双向数据流)完成，提高连接的复用率，在拥塞控制方面有更好的能力提升</li><li>使用<code>HPACK算法将头部压缩</code>，用<code>哈夫曼编码</code>建立索表，传送索引大大节约了带宽</li><li>允许<code>服务端主动推送</code>数据给客户端</li><li>增加了安全性，使用HTTP 2.0，要求必须至少TLS 1.2</li><li>使用虚拟的流传输消息，解决了应用层的队头阻塞问题</li></ul><p><strong>缺点</strong></p><ul><li>TCP以及TCP+TLS建立连接的延时，HTTP2使用TCP协议来传输的，而如果使用HTTPS的话，还需要TLS协议进行安全传输，而使用TLS也需要一个握手过程，在传输数据之前，导致我们花掉3~4个RTT</li><li>TCP的队头阻塞并没有彻底解决。在HTTP2中，多个请求跑在一个TCP管道中，但当HTTP2出现丢包时，整个TCP都要开始等待重传，那么就会阻塞该TCP连接中的所有请求</li></ul><h4 id="spdy-和-http2-的区别" tabindex="-1"><a class="header-anchor" href="#spdy-和-http2-的区别" aria-hidden="true">#</a> SPDY 和 HTTP2 的区别</h4><ul><li>头部压缩算法，SPDY是通用的<code>deflate算法</code>，HTTP2是专门为压缩头部设计的<code>HPACK算法</code></li><li>SPDY必须在<code>TLS上</code>运行，HTTP2可在<code>TCP</code>上直接使用，因为增加了HTTP1.1的Upgrade机制</li><li>SPDY更加完善的协议商讨和确认流程</li><li>SPDY更加完善的Server Push流程</li><li>SPDY增加控制帧的种类，并对帧的格式考虑的更细致</li></ul><h4 id="http1-和-http2" tabindex="-1"><a class="header-anchor" href="#http1-和-http2" aria-hidden="true">#</a> HTTP1 和 HTTP2</h4><ul><li>HTTP2是一个<code>二进制协议</code>，HTTP1是<code>超文本协议</code>，传输的内容都不是一样的</li><li>HTTP2报头压缩，可以使用HPACK进行<code>头部压缩</code>，HTTP1则不论什么请求都会发送</li><li>HTTP2<code>服务端推送</code>(Server push)，允许服务器预先将网页所需要的资源push到浏览器的内存当中</li><li>HTTP2遵循<code>多路复用</code>，代替同一域名下的内容，只建立一次连接，HTTP1.x不是，对域名有6~8个连接限制</li><li>HTTP2引入<code>二进制数据帧</code>和<code>流</code>的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况，同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。HTTP2对同一域名下所有请求都是基于流的，也就是说同一域名下不管访问多少文件，只建立一次连接</li></ul><h4 id="http-3-0-quic" tabindex="-1"><a class="header-anchor" href="#http-3-0-quic" aria-hidden="true">#</a> HTTP 3.0/QUIC</h4><p>由于HTTP 2.0依赖于TCP，TCP有什么问题那HTTP2就会有什么问题。最主要的还是队头阻塞，在应用层的问题解决了，可是在TCP协议层的队头阻塞还没有解决。</p><p>TCP在丢包的时候会进行重传，前面有一个包没收到，就只能把后面的包放到缓冲区，应用层是无法取数据的，也就是说HTTP2的多路复用并行性对于TCP的丢失恢复机制不管用，因此丢失或重新排序的数据都会导致交互挂掉</p><p>为了解决这个问题，Google又发明了<code>QUIC协议</code></p><p>并在2018年11月将QUIC正式改名为<code>HTTP 3.0</code></p><p><strong>特点</strong>：</p><ul><li>在传输层直接干掉TCP，用<code>UDP</code>替代</li><li>实现了一套新的<code>拥塞控制算法</code>，彻底解决TCP中队头阻塞的问题</li><li>实现了类似TCP的<code>流量控制</code>、传输可靠性的功能。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性</li><li>实现了<code>快速握手</code>功能。由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据。</li><li>集成了TLS加密功能。目前QUIC使用的是TLS1.3</li></ul><h2 id="➣-https优缺点" tabindex="-1"><a class="header-anchor" href="#➣-https优缺点" aria-hidden="true">#</a> ➣ HTTPS优缺点</h2><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><ul><li>内容加密，中间无法查看原始内容；</li><li>身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持；</li><li>数据完整性，防止内容被第三方冒充或篡改；</li><li>虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本； ​</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><ul><li>要钱，功能越强大的证书费用越贵；</li><li>证书需要绑定IP，不能在同一个IP上绑定多个域名；</li><li>https双方加解密，耗费更多服务器资源；</li><li>https握手更耗时，降低一定用户访问速度(优化好就不是缺点了)； ​</li></ul><h2 id="➣-http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#➣-http-和-https-的区别" aria-hidden="true">#</a> ➣ HTTP 和 HTTPS 的区别</h2><ul><li>HTTP是<code>明文传输</code>，不安全的，HTTPS是<code>加密传输</code>，安全的多；</li><li>HTTP标准端口是<code>80</code>，HTTPS标准端口是<code>443</code>；</li><li>HTTP不用认证证书<code>免费</code>，HTTPS需要认证证书<code>要钱</code>；</li><li><code>连接方式不同</code>，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次；</li><li>HTTP在OSI网络模型中是在<code>应用层</code>，而HTTPS的TLS是在<code>传输层</code>；</li><li>HTTP是<code>无状态</code>的，HTTPS是<code>有状态</code>的；</li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/frontend-summary/network_system/keys.html" class="" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a></span><span class="next"><a href="/frontend-summary/network_system/https.html" class="" aria-label="● HTTPS 协议"><!--[--><!--]--> ● HTTPS 协议 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/frontend-summary/assets/app.6a7323b4.js" defer></script>
  </body>
</html>
