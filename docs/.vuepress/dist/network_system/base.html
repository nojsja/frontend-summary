<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <title>● 基础知识 | NoJsJa Frontend Summary</title><meta name="description" content="Network & System 的描述">
    <link rel="modulepreload" href="/frontend-summary/assets/app.e1636e9f.js"><link rel="modulepreload" href="/frontend-summary/assets/base.html.ac59176a.js"><link rel="modulepreload" href="/frontend-summary/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/frontend-summary/assets/base.html.73e943f0.js">
    <link rel="stylesheet" href="/frontend-summary/assets/style.c7eaaf18.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/frontend-summary/" class=""><img class="logo" src="https://nojsja.gitee.io/blogs/img/avatar/nojsja.jpeg" alt="NoJsJa Frontend Summary"><span class="site-name can-hide">NoJsJa Frontend Summary</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://nojsja.gitee.io/blogs" rel="noopener noreferrer" target="_blank" aria-label="Blogs"><!--[--><!--]--> Blogs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/nojsja" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://nojsja.gitee.io/blogs" rel="noopener noreferrer" target="_blank" aria-label="Blogs"><!--[--><!--]--> Blogs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/nojsja" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/frontend-summary/" class="sidebar-item sidebar-heading" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/html_css" class="sidebar-item sidebar-heading" aria-label="➣ HTML/CSS 部分"><!--[--><!--]--> ➣ HTML/CSS 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/html_css/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/html_css/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/js" class="sidebar-item sidebar-heading" aria-label="➣ Javascript 部分"><!--[--><!--]--> ➣ Javascript 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/js/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/js/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/react" class="sidebar-item sidebar-heading" aria-label="➣ React 部分"><!--[--><!--]--> ➣ React 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/react/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/react/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/node" class="sidebar-item sidebar-heading" aria-label="➣ Node 部分"><!--[--><!--]--> ➣ Node 部分 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/node/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/node/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/optimization" class="sidebar-item sidebar-heading" aria-label="➣ 前端性能优化"><!--[--><!--]--> ➣ 前端性能优化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/optimization/code.html" class="sidebar-item" aria-label="● 编码优化"><!--[--><!--]--> ● 编码优化 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/optimization/http.html" class="sidebar-item" aria-label="● http 优化"><!--[--><!--]--> ● http 优化 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/optimization/build.html" class="sidebar-item" aria-label="● 构建优化"><!--[--><!--]--> ● 构建优化 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/structure" class="sidebar-item sidebar-heading" aria-label="➣ 前端工程化和架构"><!--[--><!--]--> ➣ 前端工程化和架构 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/structure/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/structure/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/structure/project.html" class="sidebar-item" aria-label="● 项目架构梳理"><!--[--><!--]--> ● 项目架构梳理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/network_system" class="router-link-active sidebar-item sidebar-heading active" aria-label="➣ 操作系统和网络"><!--[--><!--]--> ➣ 操作系统和网络 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend-summary/network_system/base.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend-summary/network_system/base.html#➣-cpu-调度算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ cpu 调度算法"><!--[--><!--]--> ➣ cpu 调度算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#➣-cookie-中常见的字段" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ cookie 中常见的字段"><!--[--><!--]--> ➣ cookie 中常见的字段 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#➣-什么是堆-什么是栈-它们之间有什么区别和联系" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 什么是堆？什么是栈？它们之间有什么区别和联系？"><!--[--><!--]--> ➣ 什么是堆？什么是栈？它们之间有什么区别和联系？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#➣-tcp-和-udp-协议的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ TCP 和 UDP 协议的区别"><!--[--><!--]--> ➣ TCP 和 UDP 协议的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#➣-浏览器缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="➣ 浏览器缓存"><!--[--><!--]--> ➣ 浏览器缓存 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend-summary/network_system/base.html#_1-浏览器缓存的工作流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 浏览器缓存的工作流程"><!--[--><!--]--> 1. 浏览器缓存的工作流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#_2-service-worker-cache-优先级最高" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Service-Worker Cache(优先级最高)"><!--[--><!--]--> 2. Service-Worker Cache(优先级最高) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#_3-memory-cache-优先级次之" class="router-link-active router-link-exact-active sidebar-item" aria-label="3. Memory Cache(优先级次之)"><!--[--><!--]--> 3. Memory Cache(优先级次之) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#_4-http-cache-优先级次之" class="router-link-active router-link-exact-active sidebar-item" aria-label="4. * HTTP Cache(优先级次之)"><!--[--><!--]--> 4. * HTTP Cache(优先级次之) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend-summary/network_system/base.html#_5-push-cache-优先级最低" class="router-link-active router-link-exact-active sidebar-item" aria-label="5. Push Cache(优先级最低)"><!--[--><!--]--> 5. Push Cache(优先级最低) <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/network_system/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/network_system/http.html" class="sidebar-item" aria-label="● HTTP 协议"><!--[--><!--]--> ● HTTP 协议 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/network_system/https.html" class="sidebar-item" aria-label="● HTTPS 协议"><!--[--><!--]--> ● HTTPS 协议 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/network_system/http2.0.html" class="sidebar-item" aria-label="● HTTP 2.0"><!--[--><!--]--> ● HTTP 2.0 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/design_pattern" class="sidebar-item sidebar-heading" aria-label="➣ 设计模式"><!--[--><!--]--> ➣ 设计模式 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/design_pattern/decorator.html" class="sidebar-item" aria-label="● 装饰器模式"><!--[--><!--]--> ● 装饰器模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/flyweight.html" class="sidebar-item" aria-label="● 享元模式"><!--[--><!--]--> ● 享元模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/observer.html" class="sidebar-item" aria-label="● 观察者模式"><!--[--><!--]--> ● 观察者模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/proxy.html" class="sidebar-item" aria-label="● 代理模式"><!--[--><!--]--> ● 代理模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/responsibility_chain.html" class="sidebar-item" aria-label="● 责任链模式"><!--[--><!--]--> ● 责任链模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/state.html" class="sidebar-item" aria-label="● 状态模式"><!--[--><!--]--> ● 状态模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/strategy.html" class="sidebar-item" aria-label="● 策略模式"><!--[--><!--]--> ● 策略模式 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/design_pattern/template.html" class="sidebar-item" aria-label="● 模板方法模式"><!--[--><!--]--> ● 模板方法模式 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/data" class="sidebar-item sidebar-heading" aria-label="➣ 数据结构"><!--[--><!--]--> ➣ 数据结构 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/data/keys.html" class="sidebar-item" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/data/base.html" class="sidebar-item" aria-label="● 基础知识"><!--[--><!--]--> ● 基础知识 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/frontend-summary/algorithms" class="sidebar-item sidebar-heading" aria-label="➣ 算法"><!--[--><!--]--> ➣ 算法 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/frontend-summary/algorithms/array.html" class="sidebar-item" aria-label="● 数组"><!--[--><!--]--> ● 数组 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/dp.html" class="sidebar-item" aria-label="● 动态规划"><!--[--><!--]--> ● 动态规划 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/linked_list.html" class="sidebar-item" aria-label="● 链表"><!--[--><!--]--> ● 链表 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/string.html" class="sidebar-item" aria-label="● 字符串处理"><!--[--><!--]--> ● 字符串处理 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/sort.html" class="sidebar-item" aria-label="● 排序算法"><!--[--><!--]--> ● 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/tree.html" class="sidebar-item" aria-label="● 树"><!--[--><!--]--> ● 树 <!--[--><!--]--></a><!----></li><li><a href="/frontend-summary/algorithms/others.html" class="sidebar-item" aria-label="● 其它"><!--[--><!--]--> ● 其它 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="➣-cpu-调度算法" tabindex="-1"><a class="header-anchor" href="#➣-cpu-调度算法" aria-hidden="true">#</a> ➣ cpu 调度算法</h2><h2 id="➣-cookie-中常见的字段" tabindex="-1"><a class="header-anchor" href="#➣-cookie-中常见的字段" aria-hidden="true">#</a> ➣ cookie 中常见的字段</h2><h2 id="➣-什么是堆-什么是栈-它们之间有什么区别和联系" tabindex="-1"><a class="header-anchor" href="#➣-什么是堆-什么是栈-它们之间有什么区别和联系" aria-hidden="true">#</a> ➣ 什么是堆？什么是栈？它们之间有什么区别和联系？</h2><p>数据结构中堆是满足父子节点大小（比如大根堆中规定父节点的值要比子节点大）关系的一种完全二叉树。由于是完全二叉树，可以用数组来实现，用节点编号来访问和操作节点，简化程序，提升效率。而其大小关系则为我们查询堆中极值提供了常数级别的时间复杂度，又由二叉树的性质，插入和删除则为对数级别时间复杂度。这就好像地位不同的人在排队，排在最前面的一定是地位最高的人，所以堆是优先队列（Priority Queue）实现的基础。利用这一特性，可以加速某些需要频繁取队列中极值的算法比如 A* 算法等。</p><p>数据结构中的栈则是一种相当简单的结构。就像是只有一个口的深深的文件桶，先进去的文件会被压在下面（push），而且我们每次只能取到最上面的文件（pop），体现了其先进后出（FILO）的特性。虽然栈操作简单，但也有如单调栈等在栈内保持一定数据特性的变种。</p><p>操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。<strong>内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存</strong>，即使是同一个程序也可能占用了不同地方的多块内存。操作系统中则会对这些空间进行统一的管理，在应用程序提出申请时，就会从堆中按照一定算法找出一块可用内存，标记占用空间等信息之后返回其起始地址给程序。在程序结束之前，操作系统不会删除已经申请的内存，而是要靠程序主动提出释放的请求（free、delete），如果使用后忘记释放，就会造成所谓的内存泄漏问题。因此堆基本上可以理解为当前可以使用的空闲内存，但是其申请和释放都要程序员自己写代码管理。</p><p>而操作系统的栈则是程序运行时自动拥有的一小块内存，大小在编译期时由编译器参数决定，用于局部变量的存放或者函数调用栈的保存。在 C 中如果声明一个局部变量（例如 int a），它存放的地方就在栈中，而当这个局部变量离开其作用域之后，所占用的内存则会被自动释放，因此在 C 中局部变量也叫自动变量。栈的另一个作用则是保存函数调用栈，这时和数据结构的栈就有关系了。在函数调用过程中，常常会多层甚至递归调用。每一个函数调用都有各自的局部变量值和返回值，每一次函数调用其实是先将当前函数的状态压栈，然后在栈顶开辟新空间用于保存新的函数状态，接下来才是函数执行。当函数执行完毕之后，栈先进后出的特性使得后调用的函数先返回，这样可以保证返回值的有序传递，也保证函数现场可以按顺序恢复。操作系统的栈在内存中高地址向低地址增长，也即低地址为栈顶，高地址为栈底。这就导致了栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把你的程序杀掉。</p><h2 id="➣-tcp-和-udp-协议的区别" tabindex="-1"><a class="header-anchor" href="#➣-tcp-和-udp-协议的区别" aria-hidden="true">#</a> ➣ TCP 和 UDP 协议的区别</h2><h4 id="一、tcp-协议" tabindex="-1"><a class="header-anchor" href="#一、tcp-协议" aria-hidden="true">#</a> 一、TCP 协议</h4><p>TCP 协议隶属于 TCP/IP 协议簇中的一个重要协议，它位于传输层。</p><p>TCP 协议是面向连接的，是一种可靠的传输协议。客户端和服务端开始通信之前需要通过三次握手保证连接正常建立，并确定连接双方都可正常收发消息。</p><p><strong>简述三次握手的过程：</strong></p><blockquote><p>SYN 这个标志位只有在 TCP 建立连接时才会被置 1 , 握手完成后 SYN 标志位被置 0。</p></blockquote><ul><li>i. 第一次握手：主机 A 通过向主机 B 发送一个含有同步序列号的标志位的数据段给主机 B，向主机 B 请求建立连接，通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。</li><li>ii. 第二次握手：主机 B 收到主机 A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机 A，也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我</li><li>iii. 第三次握手：主机 A 收到这个数据段后，再发送一个确认应答，确认已收到主机 B 的数据段：&quot; 我已收到回复，我现在要开始传输实际数据了，这样 3 次握手就完成了，主机 A 和主机 B 就可以传输数据了。</li></ul><p><strong>简述四次挥手的过程：</strong></p><ul><li>i. 第一次：当主机 A 完成数据传输后，将控制位 FIN 置 1，提出停止 TCP 连接的请求；</li><li>ii. 第二次：主机 B 收到 FIN 后对其作出响应，然后将这一方向上的 TCP 消息接收通道将关闭，将 ACK 置为 1；</li><li>iii. 第三次：B 端最后的数据传输完成后，由 B 端再发出反方向的关闭请求，将 FIN 置 1；</li><li>iv. 第四次：主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束；</li></ul><p>字段说明：</p><ul><li>ACK 是 TCP 报头的控制位之一，对数据进行确认。确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为 X，则表示前 X-1 个数据段都收到了，只有当 ACK=1 时, 确认号才有效，当 ACK=0 时，确认号无效，这时会要求重传数据，保证数据的完整性。</li><li>SYN 同步序列号，TCP 建立连接时将这个位置 1。</li><li>FIN 发送端完成发送任务位，当 TCP 完成数据传输需要断开时,，提出断开连接的一方将这位置 1。</li></ul><p><strong>TCP 协议的包头结构</strong></p><p><img src="https://nojsja.gitee.io/static-resources/images/interview/tcp-protocol.png" alt=""></p><p>源端口 16 位；目标端口 16 位；序列号 32 位；回应序号 32 位；TCP 头长度 4 位；reserved保留 6 位；控制代码 6 位；窗口大小 16 位；偏移量 16 位；校验和 16 位；选项 32 位 (可选)；</p><p>这样我们得出了 TCP 包头的最小长度，为 20 字节。</p><h4 id="二、udp-协议" tabindex="-1"><a class="header-anchor" href="#二、udp-协议" aria-hidden="true">#</a> 二、UDP 协议</h4><p>UDP 协议 (用户数据报协议) 是面向报文的，是一种非可靠协议，位于传输层，传输数据之前源端和终端不建立连接。</p><p>它适用于一些低精度的通信场景，比如网络直播，丢失了一两帧的数据，但是数据通信的性能得到了提升。</p><p>UDP 信息包头很短，只有 8 个字节。UDP 传送数据的速度仅仅是受应用程序生成数据的速度、计算机的性能和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p><p>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。</p><p>UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文， 在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p><p><strong>UDP 的包头结构：</strong></p><p><img src="https://nojsja.gitee.io/static-resources/images/interview/udp-protocol.jpg" alt=""></p><p>源端口 16 位；目的端口 16 位；UDP 长度 16 位；校验和 16 位</p><h4 id="三、总结" tabindex="-1"><a class="header-anchor" href="#三、总结" aria-hidden="true">#</a> 三、总结</h4><ol><li>基于连接与无连接；</li><li>对系统资源的要求（TCP 较多，UDP 少）；</li><li>UDP 程序结构较简单；</li><li>流模式与数据报模式；</li><li>TCP 保证数据正确性，UDP 可能丢包；</li><li>TCP 保证数据顺序，UDP 不保证；</li></ol><h2 id="➣-浏览器缓存" tabindex="-1"><a class="header-anchor" href="#➣-浏览器缓存" aria-hidden="true">#</a> ➣ 浏览器缓存</h2><h3 id="_1-浏览器缓存的工作流程" tabindex="-1"><a class="header-anchor" href="#_1-浏览器缓存的工作流程" aria-hidden="true">#</a> 1. 浏览器缓存的工作流程</h3><p>     通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p><p>     这里先看张大家最熟悉的Devtools网络图：</p><p><img src="http://nojsja.gitee.io/static-resources/images/http/network.png" alt=""></p><p>图中青色、绿色和橙色圈出的部分分别是来自内存(memory缓存)、磁盘(disk缓存)和Http请求拿到的数据(非缓存)，还有一种返回码304的请求也是从缓存(memory/disk)中获取数据。304跟memory/disk缓存的区别是：在浏览器判断资源已经过期的情况下会去服务器查询资源是否更新，如果资源没更新则返回304码，浏览器收到304码就会更新资源的过期时间并直接从之前disk/memory缓存中拿到当前资源，换言之如果资源没过期，那么浏览器就会跳过向服务器校验资源这一步并直接去拿memory/disk缓存获取。</p><p><img src="http://nojsja.gitee.io/static-resources/images/http/http_cache2.png" alt=""></p><p>大致流程如下：</p><ul><li><p>1）首先检查是否存在 Service Worker Cache，没命中或不存在则进行下一步</p></li><li><p>2）检查内存中是否存在资源，存在的话直接加载(from memory - 200)。</p></li><li><p>3）如果内存没有，择取从硬盘获取，存在且没过期的话直接加载(from disk - 200)，过期了直接向服务器发送请求获取资源。如果资源没更新，服务器返回304，浏览器从硬盘缓存中获取资源，并更新<code>过期时间/Etag/Last-Modified</code>。如果资源更新了则获取最新的资源，并通过HTTP请求将资源返回，重新缓存资源并更新<code>过期时间/Etag/Last-Modified</code>。</p></li><li><p>4）如果硬盘也没有，那么会向后端发送HTTP网络请求。</p></li><li><p>5）加载到的资源缓存到硬盘和内存，并更新资源的<code>过期时间/Etag/Last-Modified</code>。</p></li></ul><p>     <code>Service Worker Cache</code>具有较高的优先级，数据控制更为复杂，操作自由度最高；<code>Memory Cache</code>更多的强调了一种缓存存储方式和浏览器内存缓存策略；<code>HTTP Cache</code>相对于<code>Memory Cache</code>根据存储方式的不同也能叫做<code>Disk Cache</code>，它依赖于整个HTTP缓存校验流程(强缓存和协商缓存)，并通过校验来最终确定何时从缓存读取，何时从服务器更新资源；Push Cache资料较少，应用得不多，暂时只做介绍。</p><h3 id="_2-service-worker-cache-优先级最高" tabindex="-1"><a class="header-anchor" href="#_2-service-worker-cache-优先级最高" aria-hidden="true">#</a> 2. Service-Worker Cache(优先级最高)</h3><hr><p>     Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>     Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>     当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h3 id="_3-memory-cache-优先级次之" tabindex="-1"><a class="header-anchor" href="#_3-memory-cache-优先级次之" aria-hidden="true">#</a> 3. Memory Cache(优先级次之)</h3><p>     Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经获取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。内存缓存在缓存资源时并不关心返回资源的HTTP响应头部 Cache-Control 是什么值，换句话说这是一种强依赖于浏览器本地内存管理策略的缓存方式，各个浏览器对内存缓存的处理方式也略有区别。</p><p>     Memory Cache遵循这些策略：</p><ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><h3 id="_4-http-cache-优先级次之" tabindex="-1"><a class="header-anchor" href="#_4-http-cache-优先级次之" aria-hidden="true">#</a> 4. * HTTP Cache(优先级次之)</h3><p>     HTTP缓存根据工作方式分为<code>强缓存</code>和<code>协商缓存</code>，浏览器首先会判断<code>强缓存</code>是否命中，命中失败才会尝试进行<code>协商缓存</code>。</p><p><img src="http://nojsja.gitee.io/static-resources/images/http/http_cache.png" alt=""></p><p>1）强缓存</p><ul><li><p>&gt; HTTP 1.0时代 - expires<br>      我们通过浏览器获取服务器远程资源时，服务器通过http请求response headers返回一个<code>expires</code>时间戳字段(上图中蓝色部分)，例如<code>expires: Wed, 13 Oct 2021 22:15:05 GMT</code>，表明这个资源的过期时间为格林威治时间<code>2021年10月13日 周三 22:15:05</code>(北京时间+8h=格林威治时间)，浏览器判断当前时间在资源过期时间之前的话，就会从缓存中去读取资源(如果缓存中存在的话)，否则会重新向服务器发送请求。<br>      expires的工作机制要求客户端时间与服务器时间误差较小，否则缓存更新策略可能在短时间不生效。</p></li><li><p>&gt; HTTP 1.1时代 - cache-control<br>      <code>cache-control: max-age</code>方式也是通过服务器返回资源时携带的response headers中的相应字段实现的，比如：<code>cache-control: max-age=31536000</code>，表明资源距浏览器接收到此资源后的31536000秒后过期。与<code>expires</code>返回的时间戳方式不同，cache-control为了避免时间误差，直接返回一个时间长度，浏览器可以根据一个本地时间差值进行精确判断。<br><code>cache-control</code>其它相关字段还有：<br>      <strong>i.</strong> <strong>public/private</strong>：在依赖各种代理的大型架构中，我们不得不考虑代理服务器的缓存问题，public 与 private 用来控制代理服务缓存是否能缓存资源。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值，不过在只设置s-maxage的情况下，代理缓存也能生效。<br>      <strong>ii.</strong> <strong>s-maxage</strong>：针对于代理服务器的缓存问题，此字段用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，只对 public 缓存有效，<code>cache-control: max-age=3600, s-maxage=31536000</code>。<br>      <strong>iii.</strong> <strong>no-cache</strong>：为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期，直接进行<code>协商缓存</code>。<br>      <strong>iv.</strong> <strong>no-store</strong>：不使用任何缓存策略，每次请求都直接从服务器获取，并在浏览器客户端不进行资源缓存。</p></li><li><p>&gt; cache-control 和 expires 并存<br>      cache-control的优先级更高，当cache-control与 expires同时出现时，以cache-control为准，不过考虑向下兼容性可以选择同时使用两种缓存策略。</p></li></ul><p>2）协商缓存</p><p>     协商缓存依赖于服务端与浏览器之间的通信，在第一次获取资源时浏览器会存储HTTP请求的response headers字段：Last-Modified / Etag，当强缓存未命中的时候，它的值作为浏览器和服务器通信时携带的标志位用于判断资源是否过期，如果服务器判断资源过期的话就会重新下载资源，并更新相应标志位。如果判断资源未更新的话，会返回304状态码，浏览器就会复用客户端缓存资源。</p><ul><li><p>&gt; Last-Modified 和 If-Modified-Since 方式<br>      <code>Last-Modified</code>为随服务器端HTTP响应头部返回的时间戳标志，表示一个资源最近一次被更新的时间，客户端请求资源时添加上request headers字段<code>If-Modified-Since</code>(值与Last-Modified相同)用于服务器做校验判断资源是否更新，<code>Last-Modified: Wed, 13 Jan 2021 15:34:55 GMT</code>。<br> 使用 Last-Modified 存在一些弊端：<br>      <strong>i. 命中失误1：</strong> 当我们更新了服务器的某个资源文件，但其实际内容并未发生变化，其相应的资源更新时间戳会改变，浏览器端在服务端文件并未发生改变的情况下，仅仅通过时间戳这种判断方式也会导致资源被完全重新下载。<br>      <strong>ii. 命中失误2：</strong> If-Modified-Since 只能检查到以秒为最小计量单位的时间差，感知不到1s以内的文件改动的情况，这会导致一些浏览器缓存更新不及时的情况。</p></li><li><p>&gt; Etag 和 If-None-Match 方式<br>      <code>Etag</code>就是为了弥补<code>Last-Modified</code>的弊端而产生的新的协商缓存方式。Etag为随服务器端HTTP请求头部返回的资源唯一标志，例如：<code>ETag: W/&quot;2a3b-1602480f459&quot;</code>，它根据资源内容而生成，可以精确感知资源的变动情况，即使多次更新，只要内容不变，Etag值也是不会变化的。浏览器下一次请求此资源时，request headers里就会带上一个值相同的名为<code>if-None-Match</code>的字段用于服务器对此资源做对比，<code>If-None-Match: W/&quot;2a3b-1602480f459&quot;</code>。</p></li><li><p>&gt; <code>Etag</code>在感知文件变化上比<code>Last-Modified</code>更加准确，优先级也更高，不过<code>Etag</code>的生成会消耗掉部分服务器的性能，它可以作为一种辅助协商缓存方式与前者相互配合使用。当<code>Etag</code>和<code>Last-Modified</code>同时存在时，以<code>Etag</code>为准。</p></li></ul><h3 id="_5-push-cache-优先级最低" tabindex="-1"><a class="header-anchor" href="#_5-push-cache-优先级最低" aria-hidden="true">#</a> 5. Push Cache(优先级最低)</h3><p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存：</p><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li><li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: yangwei13@outlook.com">nojsja</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: hz21056646@huize.com">杨伟-hz21056646</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/frontend-summary/network_system/keys.html" class="" aria-label="● 考点梳理"><!--[--><!--]--> ● 考点梳理 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/frontend-summary/assets/app.e1636e9f.js" defer></script>
  </body>
</html>
